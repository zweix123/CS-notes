# 概述

<img src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/逻辑通信.png" style="zoom:79%;" />  
从这张图我们可以看到
+ 只有主机的协议栈有运输层，而网络核心的路由器只有IP层以下
+ 网络层实现主机之间的逻辑通信，运输层为应用进程之间提供端到端的逻辑通信

+ 进程才是通信的真正主体：复用(multiplesing)：发送方不同应用进程都可使用同一个运输层协议传送数据，分用(demultiplexing)：接收方运输层在剥去报文首部后能够把数据正确交付目的的应用进程。

+ 两个对等传输实体在通信时传送的数据单位：
	+ OSI：运输协议数据单元TPDU(Transport Protocol Data Unit)
	+ TCP/IP：TCP报文段(segment)/UDP用户数据报

## 协议
>运输层新增第三种协议：流控制传输协议SCTP(Stream Control Transmission Protcol)\[RFC 4960\]

+ 用户数据报协议UDP(User Datagram Protocol)\[RFC 768\]
+ 传输控制协议TCP(Transmission Control Protoocol)\[RFC 793\]，面向连接、可靠全双工

<img src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/应用及其协议.png" style="zoom:79%;" />  

## 端口号

协议端口号(protocol prot number)，简称端口(port)：

+ 需求：
	+ 复用和分用的过程需要标志

	>计算机操作系统中使用进程标识符区分进程  
	>但是这个方法在计算机网络中是不可以的，因为操作系统类型多，这种标识符就多

	+ 进程的创建和撤销是动态的

	所以端口的作用就是消息交付到对应端口，然后再交付到对应进程

>这里是软件端口，不是硬件端口，是应用层的各个协议进程与运输实体进程层间交互的地址。

+ 格式：16位二进制（65535个）
+ 类型：
	1. 服务端使用的端口号：
		1. [wellknown port number熟知端口号/系统端口号](www.iana.org)：0~1023  
			![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/常用的熟知端口号.png)
			可在[这里](www.iana.org)查到，是IANA指派给TCP/IP最重要的应用程序的

		2. 登记端口号/短暂端口号：1024~49151  
			需要在IANA上登记避免重复

# 用户数据报协议UDP

+ 特点：
	1. UDP是**无连接的**，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延
	2. UDP使用**尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表
	3. UDP的**面向报文**的：UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界  
		![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/UDP面向报文.png)

		因为不进行拆分，所以需要应用层控制报文大小平衡IP层性能

	4. UDP**没有拥塞控制**：对于要求恒定发送速率，允许丢失一些数据的应用
		>但也可能让网络拥塞

	5. UDP**支持一对一、一对多、多对一和多对多的交互通信**
	6. UDP的**首部开销小**：只有8个字节，比TCP的20个字节的首部要短

	>有些程序会对UDP的不可靠通信进行改进：前向纠错或重传丢失

+ 格式：（伪首部字段12字节） + 首部字段8字节 + 数据字段  
	![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/UDP数据报格式.png)

	+ 首部：
		1. 源端口：源端口号。在需要对方回信时选用。不需要时可全0
		2. 目的端口：目的端口号。这在终点交付报文时必须使用
		3. 长度：UDP用户数据报的长度，其最小值是8（仅有首部）
		4. 检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃

	+ 如果接收方UDP发现收到的报文中的目的端口号不正确就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方
	+ 检验和：把首部和数据部分一起都检验
		>伪首部的意义是其长度算上首部正好是一个16位
		1. 把UDP数据报看作多个16位的字串，检验和部分为0，不足位置为0
		2. 以二进制反码计算所有16位字串的和，写入UDP检验和部分
		3. 接收方再次求和，为1则无差错
		+ 同时能检验端口号

# 传输控制协议TCP

+ 特点：面向连接（通信前建立连接、之后释放）、点对点全双工、可靠交付（无差错、不丢失、不重复且按序）、面向字节流（有缓存）。
+ 连接：TCP把连接作为最基本的抽象
	+ 套接字Socket：IP地址拼接端口号
		>当然Socket在网络技术中有不同的意思
	+ 一个TCP是两个套接字

+ 格式：<img alt="TCP首部" src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Network/TCP首部.png" style="zoom:69%;" />  
	+ 序号（32位）：是循环的，针对的是内容字节
	+ 确认号（32位）：表示希望下一个收到的序号
	+ 控制位：
		+ 确认ACK(ACKnowledgement)
		+ 终止FIN(FINis)
	+ 窗口（16位）：这个窗口不是下面的分组（发送窗口）的个数，而且窗口内的字节个数（滑动窗口）



ARQ, Automatic Repeat-reQuest协议

+ 停止等待协议：
	+ 描述：每发送一个分组就停止等待，等待接收方发送确认消息，接收方如果在一定时间内没有收到，则考虑重传
		+ 如果发送的分组很迟才到接收方，接收方还没来得及发送确认（至少发送方还没收到确认），于是发送方认为超时于是重传了，所以接收方会收到重复分组，接收方会丢弃分组，同样的对重复的分组接收方还发送确认嘛？任然确认（实现更简单），发送方也会丢弃重复的确认。
	+ 实现：分组编号、保留已发送的分组、超时计数器

+ 重传（有多种重传机制，这里记录下超时重传）
	+ RTT, Round-Trip Time往返时延
	+ RTO, Retransmission Timeout超时重传时间

单纯的停止等待的信道利用率很低的，因为信道里空空的，一个显然的想法就是能不能相对连续的传输——流水线？为此需要更多的技术——连续ARQ协议

+ 滑动窗口：

