>对称密码学的缺点：
>+ 密钥分配问题：建立安全的密钥信道
>+ 密钥数量问题：每个传输都需要一个密钥
>+ 对用户的欺骗没有防御机制/对用户的行为没有不可否认性

+ 公钥密码学的基础：单向函数：$f(x)$计算规模可接受、$f^{-1}(x)$计算规模极大
	+ 大整数分解：两个大素数的相乘简单，但是对其结果因式分解得到两个因数困难：RSA
	+ 离散对数：求解离散对数问题(Discrete Logarithm Problem, DLP)：Diffie-Hellman
	+ 椭圆曲线

## RSA原理解读
>Rivest-Shamir-Adleman

首先，RSA加密的是数字，因为其他信息可以转换成数字，加密数字相当于可以加密所有信息，特别的，这里加密的是正整数。

称明文为`x`，密文为`y`，按照上面的$x, y \in \mathbb{Z}_n$

在RSA中，有公钥$k_{pub} = (n, e)$，密钥$k_{pr} = d$，外界通过公钥加密信息发给自己，自己可以通过密钥进行解密，而其他没有密钥的人则无法解密。
>所以这是一个单向的，我公布密钥，别人用密钥加密，只有我能解密它的密文。如果我想回复它，那么它也要再建立一个新的RSA。但不管怎么说，这么看确实是安全的。
>>其实也那么安全，比如别人可以篡改呀，比如截获别人发的信息，然后向我发送它加密的（因为每个人都能加密嘛）

这里值e称为加密指数/公开指数、私钥d称为解密指数/保密指数

具体怎么加密解密后面说，我们先说这些密钥怎么来的

1. 选择两个素数`p`和`q`
	>这里要记住一个大前提，`p`和`q`非常的大

2. 计算`n`：$n = p \times q$  
3. 计算$\phi{(n)}$：$\phi(n) = (p - 1) \times (q - 1)$
	>这里的$\phi{(n)}$是欧拉函数，表示小于等于`n`的正整数中和`n`互素的数的个数
	>`p`和`q`的乘积的欧拉函数可以由`p`和`q`来求是欧拉函数的性质，只有`p`和`q`互素时才满足（`p`和`q`都是素数嘛，素数肯定互素）

4. 选择满足条件的公开指数e：$e \in \{1, 2, ..., \phi(n) - 1\}  \bigvee  gcd(e, \phi(n)) = 1$  
	>为什么这个e肯定存在？因为$\phi{(n)}$是两个减一的素数相乘得来的，素数肯定是奇数，奇数减一肯定是偶数，偶数相乘肯定是偶数，在小于偶数的正整数中肯定有奇数，只要这个奇数大于偶数的一般，那这个奇数肯定和这个偶数互素

5. 计算满足条件的私钥d：$d \times e \equiv 1 \ mod \ \phi(n)$

+ 逆元：如果$a \times b \equiv 1 \ mod \ n$，则称`a`和`b`在模`n`下互为逆元，可以不表示为$a^{-1} = b (mod \ n)$或者$b^{-1}=a (mod \ n)$（这里的负号不是负一次幂的意思，单独表示逆元）  
	那么它有什么用呢？在取模的意思下，加减乘都符合分配律（`a % n + b % n == (a + b) % n`，对应的减法和乘法都符合），但是除法不符合，如果`a`和`b`有逆元$a^{-1}$和$b^{-1}$，那么`a % n / b % n`可以转换成$a \% n * b^{-1} \% n$，继而可以使用乘法的分配律，那为什么可以这样转换呢？
	$$
	\begin{align}
	x \times x^{-1} &\equiv 1(mod \ n) \\
	x^{-1} &\equiv 1 / x (mod \ n)
	\end{align}
	$$

	所以除以b可以转换成乘以b的逆元

现在回到RSA

+ 为什么这样的逆元一定存在？因为扩展欧几里得算法可以求逆元，它的条件就是参数互素，上面已经保证参数，即`e`和$\phi{(n)}$互素，如果欧几里得是可证确的，那么这步就是可正确的。
	>这里讨论扩展欧几里得算法

至此，RSA的参数我们已经都计算出来了，上面说的加密解密到底是什么样子的呢？

加密函数为：$y=  e_{pub}(x) \equiv x^e \ mod \ n$    
解密函数为：$x = d_{k_{pr}}(y) \equiv y^d \ mod \ n$  

+ 正确性：明文从加密到我们解密分别对`e`和`d`取幂且对`n`取模了，即我们要证明
	$$
	x^{e \times d} \equiv x (mod \ n) 其中 ed \equiv 1(mod \ \phi{(n)})
	$$
	这里就好玩了。  
	从右边的前置条件看$$e \times d = k \phi{(n)} + 1$$想想取模的含义。  
	而左边的求证可以变形成$$x^{e \times d - 1} \equiv 1 (mod \ n)$$想想取模的性质
	上面带入下面$$x^{k\phi{(n)}} \equiv 1 (mod \ n)$$
	这里我要恰到好处的引入欧拉定理$$对于任意正整数a和与其互质的正整数n，有a^{\phi{(n)}} \equiv 1 (mod \ n)$$带入等式即成立。

+ 安全性：每个人都知道这个算法，只要推导出`d`来就算破解了，我们来看看想要破解这个需要什么。其实就需要个$\phi{(n)}$啦，但是如果从欧拉函数的定义去求复杂度是线性的，这里的这个线性可太大喽，如果想推出来`p`和`q`，则回到了为什么RSA是一个安全的公钥算法，因为目前也没有反推出来`p`和`q`的有效算法。
	>其实还有其他算法求欧拉函数，但是既然RSA是安全的，那么可以大胆猜测肯定其他方法也不够快呗。

至此，我觉得我应该是把RSA讲清了。

### 工程实现

RSA使用：取幂取模：经典快速幂。

---

密钥生成：大素数：
>素数的普遍性：$P(p为质数)\approx \frac{1}{ln(p)}$

> 精确的$O(\sqrt{n})$算法在n非常大的时候仍然无法使用，下面提供一种$O(log_2n)$的**概率**算法

+ 费马小定理：$如果p是素数，1 \le a \le p - 1, 则  a^{p - 1} \equiv 1 \ (mod \ p)$，那么对于其逆定理，是否是真命题呢？不成立，但大概率符合
	+ 如果一个数符合费马小定理中的行为，那么它有概率（大于1/2）是素数
	+ 卡迈尔克数$C$：这些合数在费马定理中的行为和素数一样，又称为**伪素数**（在前10亿个自然数出错的可能性是0.011）
		>对于特定的a，有一些合数可以通过测试，又称它们为以a为底的伪素数

+ 二次检测定理：$如果p是素数，0 < x < p，则 \\ 如果x^2 = 1(mod \ p)成立，则x = 1或x = p - 1$，那么找一些x其取方模p都不是1，p是不是素数呢？不一定，但有概率是

Miller-Rabin素性判定：运用费马小定理和二次检测定理的概率算法（如果经过两个定理的检测都没事，就认为它大概率没事）

### 对RSA加密的攻击

## Diffie-Hellman
Diffie-Hellman密钥交换(DHKE)
+ 公开文献中发布的第一个非对称方案
+ 应用技术：安全外壳SSH、传输层安全TLS、Internet协议安全IPSec

1. 握手协议：
	1. 选择一个大素数`p`
	2. 选择一个整数$\alpha \in \{2, 3, \dots, p - 2\}$
	3. 公开`p`和`a`

2. 密钥交换：
	1. a：选择$a = k_{pr, A} \in \{2, \dots, p - 2\}$  
		b：选择$b = k_{pr, B} \in \{2, \dots, p - 2\}$
	2. 计算：$A = k_{pub, A} \equiv \alpha^a mpd \ p$  
		计算：$B = k_{pub, B} \equiv \alpha^b mpd \ p$
	3. 交换
	4. 计算：$k_{AB} = k_{pub, b}^{k_{pr}, A} = B^a mod \ p$  
		计算：$k_{AB} = k_{pub, A}^{k_{pr}, B} = A^b mod \ p$

  密钥是两个互不知的两个数做指数，得到一个共知的密钥

  + 密钥选择为什么不选1和p-1
    1. 为什么不选1：幂不变，只需要知道另一个人的密钥即可破解
    2. 为什么不选p-1：由费马小定理$\alpha^{p - 1} \equiv 1 \ mod \ p$，效果同选1
  + 注意：$\alpha^{a \ b} = \alpha^{a + b} \neq \alpha^a \times \alpha^b$

## ECC椭圆曲线

+ 私钥是一个倍数、公钥是一个点——基点

+ GPT说：
	
	椭圆曲线加密算法（Elliptic Curve Cryptography，ECC）是一种基于椭圆曲线数学结构的公钥加密算法。常见的椭圆曲线加密算法包括：
	+ ECDSA：椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm），用于数字签名和身份认证等领域。
	+ ECDH：椭圆曲线Diffie-Hellman密钥交换算法（Elliptic Curve Diffie-Hellman），用于密钥交换和数据加密等领域。
	+ ECIES：椭圆曲线集成加密方案（Elliptic Curve Integrated Encryption Scheme），是一种基于ECDH和对称加密算法的加密方案。
	+ ECMQV：椭圆曲线Menezes-Qu-Vanstone密钥交换算法（Elliptic Curve Menezes-Qu-Vanstone），用于密钥交换和身份认证等领域。