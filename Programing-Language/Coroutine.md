+ 区分并行和并发：
	+ 并发：交替的运行多个“程”
	+ 并行：一起运行
---
Python的协程是通过生成器实现的，由解释器调度，只有一个协程阻塞了（比如在网络通信），才会进行切换，而Golang的协程真的类似“小线程”，可以利用多核次处理器进行并发。还记得Python的GIL嘛？即使有了协程，依然是一把大锁，python协程的优化仍然是诸如“网络通信中通信时间占大部分”这样的性质决定的。在这样的情况下，如果在单核处理器上，Python的协程形式上仍然没有区别。但是这里注意Python的调度是“一个协程阻塞，由解释器调度”，但是Golang则是类似操作系统的时间片轮转，仍然是并发，这是由Go语言运行时环境实现的。

或者说

+ 调度方式：
	+ Python协程的调度是基于协作式的，即每个协程自行决定何时让出执行权。
	+ Golang协程的调度是基于抢占式的，即调度器会在每个goroutine执行一定的时间后强制切换到其它goroutine执行。
+ 并发模型：
	+ Python协程是基于IO事件驱动的并发模型，适合处理IO密集型的任务。
	+ Golang协程是基于多线程并发模型，适合处理CPU密集型的任务。
---
C++20也有协程，那么C++的协程和上面比怎么样？
+ 性能：协程是在编译时实现的
+ 灵活：可以手动控制协程的调度，继而可实现特定的并发模型
+ 内存占用：使用栈来储存上下文。

## 有栈stackful协程?无栈stackless协程?
这里栈不是指栈，而是指协程之间有无Callback Stack调用栈

+ 在有栈协程的概念下可以把协程理解为可以中断并恢复执行的函数
	+ 通过调用进入一个协程，是非对称协程，即协程之间有明显的调用关系
	+ 调用者需要调用的协程主动的放权（yield）
+ 无栈协程则是状态机，协程的切换不过是指令寄存器的改变
