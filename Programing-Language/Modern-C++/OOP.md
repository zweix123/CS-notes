OOP即Object Oriented Programming面向对象程序设计，其核心思想是数据抽象（类的接口和实现分离）、继承和多态。
>感觉对OOP相关思想的理解对实际编码并没有用处，本质是提升项目代码结构的倾向，这种倾向是自然而然的。

# 基本概念

## 类

+ 编码规范：
	+ 类声明：以*数据成员*描述数据部分，以*成员函数*，或者说*方法*描述**接口**
	+ 类方法定义：类成员函数的实现

	通常分成同名的两个文件，一个为`.cpp`文件，一个为`.h`文件，前者放声明、后者放定义。

+ 类声明：
	```cpp
	class Widgt {
	  private:
		...
	/*
	  protected:
		...
	*/
	  public:
		...
	};
	```

	+ 关键字`class`，后接类名
		+ 类前关键字`class`和模板中模板参数前的关键字`class`不同。
		+ 类名命名约定：首字母大写

	+ 访问控制：访问说明符access specifiers：指定下面代码中成员的访问级别，有效范围到下一个访问说明符或者类的末尾。

		+ `private`私有：外界不可访问，内部可访问
		+ `public`共有：外界内部均可访问
		+ `protected`保护：外界不可访问，内部子类可访问

		共有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。

		+ 默认：`struct`共有，`class`私有

+ 内联方法：内联的成员函数
	+ 定义位于声明自动成为内联方法
	+ 定义前使用关键字`inline`

+ 静态类数据成员：所有对象共享同一个静态成员，没有this指针，不能通过对象调用，不与特定对象关联，只能使用静态数据成员，存储位置是静态内存。
	+ 声明：关键字`static`  
	+ 初始化：通过定义，不加`static`关键字，在类声明外单独初始化；一般定义在`.h`文件
		+ `const`的integer、enum、double（C++11）类型可以在类声明中初始化

	+ 使用：通过作用域运算符访问`ClassName::static_value`

+ 类方法定义：
	+ 定义成员函数时，使用作用域解析运算符表示函数所属的类：
		```cpp
		// .cpp file
		RetType ClassName::Mothed(Argument...) {...}
		```

	+ `const`常量成员函数：即函数头中参数列表右边的右括号到代码块左括号之间有关键字`const`，表示该调用不会修改数据成员。

		本质是指定`*this`是`cont`的
		+ 重载决议：非const对象优秀调用非const成员

## 对象

+ 创建
+ 初始化
+ 使用

## `this`指针

`this`指针作为隐藏参数传递给方法

## 类作用域

类也是一层作用域

## 运算符重载

C++允许将运算符重载扩展到用户定义的类型，即将重载的概念扩展到运算符上，这也是OOP中多态的一种形式

+ 语法：
	+ 声明和定义：
		```cpp
		class Widgt {
			RetType operator Op (Argument...);
		}
		RetType Widgt::operator Op (Argument...);
		```

		Op为C++[有效的运算符](https://en.cppreference.com/w/cpp/language/operators)，参数列表和运算符有关。

		+ 同样的，`this`指针被隐式的作为参数列表的第一项。

	+ 调用：
		+ 编译器将`obj1 op obj2`转换成`obj1.operator op (obj2)`，当然，也能显示调用。

+ 注意：
	+ 比如`i++`和`++i`
	+ 关于`->`运算符的重载：
		```cpp
		type* operator -> () const {
			return & this->operator*();
		}
		```

		因为这样才符合`/->mem`等价于`(*obj_p).mem`

## 类型转换

+ 自动隐式转换：当类有只有一个形参需要实参的构造函数时，可直接类似基本类型赋值进行隐式转换  
	如果不需要或者不应该，可使用关键字`explicit`放在构造函数前面表示禁止

+ 显示强制转换：`ClassName ObjName = (ClassName) value;`条件同自动隐式转换  
	+ 本质是隐式函数调用，既然是函数调用，就可以有决议：
		```cpp
		Class Widget {
		  public:
		    Widget(int);
		};

		Widget = 1.0;
		```
		这也是行的

		+ 当出现重载时，编译器优先找自定义类型的匹配，再找内置类型

	以上可以发生在初始化、赋值、传参、函数返回中。

	>这什么勾八特性，太容易出现歧义了吧，这绝逼不是最佳实践，应该禁止呀

+ 转换函数，一种运算符重载：将自定义类型转换成内置类型

	```cpp
	class Widget {
		operator bool() {...}
	};
	```

+ 场景：类型转换函数和友元函数的冲突，建议转换单一的某个类型，但是分别有些问题。

# Special member functions

这里名称不统一，C++ Primer翻译为类标准函数，C++32讲的是拷贝控制函数或者特殊函数，这里的标题使用的是cpp ref的叫法，下面文本仍然使用“标准函数”，本质是对一个数据对象各种行为的描述。

## 控制

标准函数中的有些行为有时对一个类型来说是必不可少的，如果我们没有显式定义，编译器也会自动生成相应代码，这部分是可控制的，也有很多默认的规则。个人认为最佳实践就是全部手动控制。

+ 成员状态：隐式声明还是用户声明、默认提供还是用户提供、正常状态还是删除状态，其中互相有关联。
+ 关键字：`default`和`delete`，在声明或者定义方法后添加`= 关键字`
	+ `default`：显式要求编译器默认生成标准函数
		+ 即使用户要求默认提供，编译器也可能根据其他规则将特殊成员函数删除
	+ `delete`：显式要求编译器不生成标准函数
		>C++98通过将对应函数设置为私有且不定义的方法控制
		>+ 设置私有：保证外界不使用
		>+ 不定义：保证友元不使用（编译报错）
		>
		>`delete`关键字的好处是编译报错更友好

+ 自动生成规则（一部分）：
	+ 对于两个拷贝操作，如果只声明了其中一个，不影响编译器生成另一个
	+ 对于两个移动操作，如果只声明了其中一个，编译器一定不会生成另一个
	+ 对于拷贝和移动操作，如果只声明了其中一个，编译器一定不会生成另一个

## 构造函数

+ 声明/定义：函数名与类名相同，没有返回值
+ 成员初始化：
	+ 初始化列表
	+ 默认初始化
+ 构造函数变种：
	+ 委托构造函数delegating constructor：使用**自己其他**构造函数执行自己的初始化——初始化列表是自己其他构造函数
		+ 最佳实践：重复代码时使用。

	+ 转换构造函数(convertin constructor)

## 析构函数

+ 声明/定义：函数名与类名相同，函数名前有字符`~`，没有返回值和参数
+ 调用时机：由编译器决定

## 拷贝构造函数

## 拷贝赋值运算符

## 移动构造函数

## 移动赋值运算符

## 析构函数
