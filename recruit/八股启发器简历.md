+ 八股Ref：
	+ [CSView](https://www.csview.cn/)

+ 发心：
	+ “八股启发器”来自于这样的方法论：在简历中的内容涉及尽可能多的“考点”，当面试官提问时，面试候选人可以链式的启发一系列的知识点，即可以聊的更久，又能给面试官更多可以追问的东西。
		+ 该方法论有一定的问题：面试官在面试过程中往往有自己预设的题目和节奏，该思路其实很强势，会反过来影响面试官预设的流程。
	+ 既然在构造简历时已经预设了一些问题，那么相关问题在多场面试中可能被多次问到。实际上面试官总要根据简历上的经历具体的问一些问题。这些问题和答案分散在各个面试中不好管理。故放在该文件中总结。
		>当然各个面经也未不保证问题和答案齐全。

	这里关于项目的内容和问题无所谓，但是涉及到工作经历可能涉及保密相关的问题。酌情保留。

+ 自我介绍：

+ 和HR的Argue话术（来自叔叔）：
	>核心原则就是不要自己先开价

	因为目前秋招还在进程中嘛，我还在看很多机会，目前可能不太好明确自己能接受的价位。不然未来有更高的开价我这边变卦也是不好的嘛。不过我了解过咱们公司的Package范围，我觉得整体来说是非常不错的。我觉得公司既然看好我，应该也愿意在这个基础上给出一个代表认可的价位嘛，那我觉得对我来说来说还是很不错的。不过您也理解我最终肯定得对比之后做出最终的选择嘛。但是在相同的价位里，我还是非常愿意优先选择咱们公司的。

# 手撕算法
>随缘记录

+ 题单Ref：
	+ [neetcode](https://neetcode.io/practice)
	+ [lc hot100](https://leetcode.cn/studyplan/top-100-liked/)

+ 缓存：
	+ LRU
	+ LFU
 
+ 数之和：
	+ 两数之和：在一整数数组中找到两个不重复的元素其和为给的Target，找到所有
		+ 暴力枚举：$O(n ^ 2)$
		+ 排序+枚举二分：$O(nlgn + n \times lgn)$，排序和查找
		+ 排序+双指针：$O(nlgn + n)$
		+ 哈希表：$O(n)$
	+ 三数之和：在一整数数组中找到三个不重复的元素其和为0，找到所有
		+ 如果一个数字确定，则问题转变成两数之和，即可以在两数之和的时间复杂度上加一个`n`即可
	+ 四数之和：同上

+ 单调栈：
	+ 去除重复字母

+ 动态规划：
	+ 编辑距离

+ 接雨水：
	+ 盛最多水的容器
	+ 接雨水
	+ 接雨水Ⅱ

# 项目

## C++网络编程 | Redis: Redis的Modern C++实现

```
C++17 实现，基于 CMake，Github: https://github.com/zweix123/zedis，约 3000 行
- 封装 C 风格接口 (网络接口和系统调用)，通过 RAII 管理文件描述符和套接字正确关闭。
- 主要以侵入式数据结构的实现内部数据结构: 基于拉链法实现渐进调整的可扩展哈希表，结合 AVL 树实现有序集，通过有序链表实现 TCP 连接定时器，通过堆实现键的 TTL。
- 结合惰性删除和线程池实现键的异步销毁来提高性能和响应速度。
```

+ [C++相关](#C++)

+ Linux Socket编程相关：
	+ OS kernel会维护两个队列：TCP半连接队列和TCP全连接队列
		+ 如果全连接队列非空则给`accept()`函数返回一个套接字
		+ Socket文件的inode指向Socket结构体，里面有两个队列（用链表实现），元素是`strcut sk_buff`，这个结构体即维护网络中**各个层**的数据包，是的，一个结构体维护各个层的，因为首部大小是固定的，运行是层层套娃包装解包即可。
		+ 关于TCP连接三次握手和这两个队列的关系如下图：  
			![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/recruit/TCP三次握手和TCP队列的关系.jpg)

		+ 那么如果TCP连接请求超过半连接队列的大小呢？可选直接丢弃或者发送reset包，建议直接丢弃，因为这时客户端会以为超时于是重新尝试建立连接，而如果收到reset包客户端可能认为服务端已经G了。

	+ IO多路复用：一个进程维持多个Socket
		>普通的多进程多线程并发有一定的缺点，除了本身的缺点外，还有并发的数量是有上限的

		+ `select`：将已连接的Socket放在一个集合中，`select`将其拷贝到内核中，由内核检测是否有网络事件的发生（遍历），然后修改集合中Socket的某个标记（可读/可写），然后把集合拷贝回用户态，然后在遍历一遍找
			+ 这里的集合是BitsMap位图
			+ 问题：两次遍历、两次拷贝，且集合运行最大值有限
		+ `poll`：较于`select`的区别是将固定大小的集合换成链表实现的动态数组
			+ 问题：Socket数量依然受到系统文件描述符限制
		+ `epoll`：使用红黑树跟踪进程所有带检测的文件描述符，使用事件驱动，维护一个链表记录就绪事件。
			+ 边缘触发：当有就绪事件发生时就苏醒一次，必须一次将所有就绪事件读完
			+ 水平触发（默认）：当有就绪事件发生时就不断苏醒

		---

		+ 关于读的问题

+ Redis：
	+ 应用1：服务数据存储在数据库中，数据库就要落盘，就慢，所以把Redis作为缓存层
		>就像OS中的TLB

		+ 为了让缓存和数据中的数据保持一致性，就给Redis的数据设置过期时间，这样就可能发生不命中，于是去数据库读并重新加载缓存，实现一致性

	 + 缓存雪崩：如果恰好大量缓存数据在同一时间过期了，或者Redis Server直接G了，于是大量请求直接到了数据库这里，让其压力骤增。
		 + 大量数据同时过期
			 + 均匀设置过期时间，比如给过期时间加上一个随机数 
			 + 互斥锁：对于未命中情况，锁一下，保证只有一个请求来加载缓存，这个锁也要TTL，防止请求的Client G了
			 + 后台更新缓存：解耦下，不同TTL了，让专门的模块负责，缓存不使用TTL，而是使用内部淘汰  
				此时怎么解决未命中
				+ 后台程序频繁更新检测
				+ 将未命中通过消息队列告知后台程序更新，然后重新请求

				缓存预设，即在服务开始前进行缓存，防止初期大量未命中
		+ Redis Server 故障宕机：
			+ 服务熔断或者请求限流
			+ 分布式
	+ 缓存击穿：对于热点数据，一旦过期，就有大量的请求到了数据库这里，是缓存雪崩的子集。
	+ 缓存穿透：如果因为业务操作失误或者黑客恶意攻击导致数据既不在Redis缓存中，也不在数据库中，这样大量的、多次的请求都会miss，然后频繁的访问数据库
		>上面两个请求在更新缓存后就会缓解数据库压力。

		+ 缓存空值或者默认值
		+ 非法请求限制：
			+ 在请求到达存储服务之前Check下key是否存在
			+ 在请求到达数据库之前Check下key是否存在
		+ 布隆过滤器：一个N位位图，N个哈希函数，对key求N次哈希然后取模，将对应位置置一；虽然很容易冲突，但这仅意味着，布隆过滤器说有不一定有，但是布隆过滤器说没有肯定没有。

	+ Redis中的分布式
	+ Redis的数据结构
		+ `SDS`，就是C++的string
  + Redis的网络模型是怎样的，才能保持低延迟？
    + 单线程模型
    + 非阻塞IO
    + 内存存储
    + 响应式命令执行
    + 优化的“应用层”网络协议

+ 线程池的作用
	+ 在并发中：
		+ 多进程的问题是上下文切换的开销大
		+ 多线程的问题是创建一个线程的开销不小
		+ 线程池主要是解决创建线程的开销的。

## 操作系统: xv6

```
为操作系统 xv6 添加并优化若干系统调用，使用共享内存授权用户态读取部分进程数据，避免进入内核态。完成Copy-on-Write 机制，将物理内存分配延迟到页面写入时，提高了 fork() 调用的执行效率。实现抢占式用户级线程：使用时钟中断处理调度信号，实现用户级中断，并完成线程调度与上下文切换逻辑。
```

+ 这里总结下xv6实验内容
	+ Lab: Xv6 and Unix utilities：启动xv6和利用一些Syscall实现些小应用
	+ Lab: system calls：调试xv6和添加两个系统调用mini strace和sysinfo
	+ Lab: page tables：加速系统调用：1. 设置内核和用户的共享内存页缓存信息；2. 添加系统调用展示页访问情况
	+ Lab: traps：添加系统调用实现用户级中断。
		+ 
	+ Lab: Copy-on-Write Fork for xv6：
	+ Lab: Multithreading：
 
+ 进程和线程的区别
+ 进程的通信方式和线程的通信方式

+ Linux splice机制
+ 软连接和inode

## 计算机网络: Stanford CS 144

```
项目基于 CMake，使用 C++20 实现。通过循环队列实现字节流缓存，实现对失序字节流的重排器；TCP 发送端维护滑动窗口实现超时重传。实现数据链路层和网络层的接口，即 IP 数据报和以太网帧的相互转换和正确发送；缓存 MAC 地址到 IP 地址的映射，实现 IP 的路由选择。
```
![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/recruit/TCP状态转移.png)

+ 长域名短域名问题：
	>Reference：[力扣讨论](https://leetcode.cn/circle/discuss/EkCOT9/)

	+ 使用：服务器维持长短域名的映射，短链接请求返回状态码302（重定向）和Location值即为长域名
	+ 生成方法：
		+ 哈希+数据库
			+ 怎么应对哈希冲突
				+ 布隆过滤器+多次哈希
		+ 自增序列

+ 为什么需要HTTPS：
	+ HTTP1.1的问题：
		+ 不加密，被窃听
		+ 不验证通信方身份，被伪装
		+ 不验证报文完整性，被篡改
	+ HTTP2.0较于HTTP1.1的改进
		+ 多路复用，HTTP2.0可以在单个连接上同时发送多个请求和响应，而HTTP1.0不行
		+ 头部压缩
		+ 二进制协议，HTTP1.0使用的是文本协议
		+ 服务器推送和流量控制

	在传输层加上SSL, Secure Sockets Layer 安全套接层或者TLS, Transport Layer Security安全层传输协议。即HTTP先和SSL/TLS通信，再由其和TCP通信

+ TLS握手

+ 在浏览器输入网址并回车到网页渲染完毕这之间发生了什么？
	>网址->域名

	1. 输入网址
		+ 浏览器的历史网址补全
	2. 查找网址对应的IP地址
		1. 查看本地缓存，具体就是hosts文件
		2. 浏览器发送DNS请求到本地的DNS服务器，同时，它也查询缓存，否则进入下面的流程
		3. 首先访问13台根服务器，根服务器会告诉本地DNS去哪个域服务器查询  
			这个过程是递归/迭代的，因为域名由`.`分割，指导完整域名（最低级域名的服务器），给到本地服务器的域名和IP地址映射关系。

		+ 上面的这个那个递归/迭代真的分两种形式，递归的，迭代的，顾名思义。
		+ DNS域名空间：根域——顶级域——第二层域——自域——主机名
		+ DNS负载均衡：一个域名配多个机器。
	3. 浏览器向Web服务器发送一个HTTP请求：浏览器拿到域名对应的IP地址后，和随机端口（`(1024, 65335)`）组合向服务器Web程序（怎么指导Web程序的端口号呢？）发送TCP连接请求



+ 在浏览器输入网址后会发生什么？
	1. DNS解析：浏览前检测本地DNS缓存中是否存在该域名对应的IP地址，如果没有
	2. 建立TCP连接
	3. 发送HTTP请求
	4. 服务器处理请求并返回HTTP相应
	5. 浏览器解析渲染页面
	6. 断开TCP连接

## 数据库: MIT 15445

```
我并没有做完、没有写在简历上，这里只是为了文章结构的统一
```

+ 什么是事务？比如转账，首先一方减少钱、另一方增加钱，这个过程必须是原子的，即开启事务和提交事务。
+ 事务都有哪些特性呢？原子性（原子）、一致性（正确）、隔离性（多持物冲突解决），持久性（事务处理结束后，对数据的修改是永久的，即使机器故障），这就是**ACID**
	+ 在InnoDB引擎中，持久性通过redo log保证，原子性通过undo log保证，隔离性通过MVCC（多版本并发控制）保证，一致性通过前三者保证。
	+ 多事务可能出现的问题：
		+ 脏读：事务读到了另一个未提交事务修改过的数据（因为未提交的事务随时可能回滚）
		+ 不可重复读：同一事务中多次读取的数据不同
		+ 幻读：同一事务中按某个条件查询记录数量多次查询的结果不同
		
		以上问题的严重性递减

	+ 隔离级别：隔离级别越高，性能越低
		+ 读未提交：事务未提交，它的变更就可以被其他事务看到
		+ 读提交：只有读提交了，它的变更才可以被其他事务看到
		+ 可重复读（InnoDB默认）：一个事务执行看到数据一致
		+ 串行化：锁

		隔离级别递增

	+ 在可重复度的隔离级别可**尽量**避免幻读
		+ 快照读：通过MVCC解决
		+ 当前读：通过记录锁+间隙锁解决幻读

	上面的读提交和可重复度就会使用Read View，只是创建时机不同
	+ Read View：
		+ 四个字段：事务ID、创建时“活跃且未提交的事务”的ID列表、列表的最小ID、数据库要处理的事务ID
		+ 聚簇索引

+ PostgreSQL较于MySQL的先进性：

## 编译原理: 动态语言解释器

```
将代码转换成字节码然后在虚拟机中运行，数据类型支持列表，语法支持闭包、类和垃圾回收。
C 语言实现，由 make 构建，Github: https://github.com/zweix123/zlang，约 3000 行。
- 扫描器按需扫描，编译器单遍编译，使用 Pratt 解析表达式，虚拟机为栈式虚拟机。
- 通过 Tagged Union 实现多态，基于开放寻址法实现可扩展哈希表，驻留字符串优化名称访问速度，局部变量通过编译期确定 slot 位置优化读写速度，使用 upvalue 技术实现闭包，垃圾回收采用标记清除算法，通过三色标记自适应清除。
```

## 系统设计/分布式: 6.824

+ [CAP理论](../Distributed-System/README.md#consistenct-issues-and-consensus-algorithms)
+ 负载均衡问题：
	+ 一致性哈希：如果在负载均衡的机器中各个机器不是等价的（请求必须到特定的机器上），怎么实现？
		>Reference：[小林](https://www.xiaolincoding.com/os/8_network_system/hash.html)

		对机器进行编号，然后对请求进行哈希取模确定机器，  
		但是当集群扩张了怎么办（模数变化了），就需要把对应的机器上的数据进行迁移，这个是需要成本的，而且最坏情况想很大。

		一致性哈希解决这个问题

		把上面取模的模数变成$2 ^ {32}$，把请求映射到一个大的哈希环上，然后也将机器映射到哈希环上（比如对MAC地址和IP地址取模）  
		这样添加或删除一个机器只会影响一段数据（一个机器的），控制迁移成本。

		但是仍然有缺陷，机器的位置是不均匀的，可能某个段的范围很大。
		>艹，不能把哈希函数做的均匀点么？

		再套一层哈希，把机器均匀的映射到哈希环上
		>那请求的哈希映射不均匀不还是G了吗？【恼火】

# 实习

## 网易（杭州）网络有限公司 分布式存储系统开发 实习生

```
+ 参与开发 Curve Tools 由 C++ 版本向 Golang 版本的迁移，添加块存储相关命令。
+ 作为主要开发负责量化交易系统，系统由 Python 开发、交易资产为数字货币期货交易、支持 Binance 和 OKEX 两个平台，主要支持高频轮询式策略。
+ 交易接口模块：使用 Request 模块为平台 Restful API 封装客户端，客户端接口统一，用户同一套策略可以运行于两个平台；封装 Python 原生有栈协程，实现接口好用、性能高的异步网络库。
+ 策略管理模块: 使用 Flask 框架 + multiprocessing 模块 + logging 模块实现通过网页进行多策略的监控和交互；其中日志模块在用户层面简洁统一好用。
+ (针对轮询式策略的)回测模块: 接口和实盘交易接口相同，用户无需修改代码，接口内部对接市场模拟模块；通过 Sleep 函数实现策略代码和回测代码的跳转；通过减少运行热点时的系统调用进行调优，性能优化4倍。
```

+ 项目介绍
	+ 之后被“借调”出去负责量化交易系统开发，之所以让我一个实习生来做是因为起初想通过在开源项目上进行开发，我调研之后不行，因为策略同事本来的策略是在“发明者”这个平台，它支持的是轮询式的策略，而市面上绝大部分项目支持的是事件式的。
		+ 什么是事件驱动的，它的整体框架是什么？从实盘到回测，然后同样的需求在轮询式中是什么样子的？
			+ 事件驱动的
				+ 设置一个基类，用户的策略都是从其派生出去的，从语法层面去限制用户能实现要实现什么东西来构成策略
				+ 整个项目分成两个独立引擎，一个策略管理，一个是网关对接市场，在市场出现某些信息时通知策略管理引擎去调用（因为用户能实现什么方法是固定的，引擎不知道里面的内容，但是可以去对应的位置取）
				+ 那么在回测中只需要添加一个市场模拟模块，它自顾自的移动数据，把信号给到网关，或者相应网关的什么要求。
			+ 那么轮询式的呢？
				+ 它在实盘上反而简单，因为针对数字货币、波动更大，轮询的本质就是用户策略Sleep以下
				+ 但是在回测上就遇到了问题，因为数据的移动需要依托于用户策略，而这部分式系统不可控的。
				+ 我的实现是把Sleep和平台API当作类似OS中的系统调用的东西，进入到策略后，策略如果调用这些接口则进入到市场模拟部分，相应的移动数据和交互信息。
		+ 然后是项目整体，我们连同策略和系统一起买到用户，用户将其放在自己的服务器上使用自己的钱去运行，所以我还要实现一个基本前后端用于用户查看策略日志

## 浙江智臾科技有限公司数据库内核研发实习生

```
+ 数据重平衡
+ 流表写入低延时
```

# 技能

```
- 熟悉 Modern C++, 了解 C++ 并发编程; 熟悉 Python 语言, 开发有以 Human Readable 的 Object Printer; 了解Go 语言, 有相关开发经验 (实现 B+ 树、单机区块链、MapReduce 等)。
- 基本的前端知识和一定的产品思维，开发有使用 Markdown 方言生成基于 Reveal.js 的 Web Slide 框架 (Github:https://github.com/zweix123/jyyslide-md)、交互非常自然的简历生成器 (Github: https://github.com/zweix123/resume-template)
```

## C++

+ C++11到C++20有哪些大的改动？

	C++20较于C++11是类似C++11较于C++98一样的一个主要版本，我个人感觉变化比较明显的有

	+ `constexpr`相关特性变得越来越多
	+ C++17的结构化绑定
	+ SFINAE替换失败非错

+ 移动语义解决了什么问题？

+ `NULL`和`nullptr`的区别：后者具有类型
+ `new/delete`和`malloc/free`的区别：
+ `unique_ptr`相比于raw ptr是否会有任何性能损失：因为它是基于模板的类型擦除技术，而不是虚函数表
	+ 类型擦除
	+ 虚函数表

+ 手撕智能指针
+ 无锁编程：
	+ Ref：[Cool Shell](https://coolshell.cn/articles/8239.html)
	+ CAS操作，Compare and Set
		```c
		int compare_and_swap (int* reg, int oldval, int newval) {
		  int old_reg_val = *reg;
		  if (old_reg_val == oldval) {
		     *reg = newval;
		  }
		  return old_reg_val;
		}
		// 或者
		bool compare_and_swap (int *addr, int oldval, int newval) {
		  if ( *addr != oldval ) {
		      return false;
		  }
		  *addr = newval;
		  return true;
		}
		```

		类似的还有Fetch and Add（原子+1）, Test and Set（赋值并返回原值）, Test and Test-and-Set
	+ Modern C++中的CAS：[Atomi Operation Library](https://en.cppreference.com/w/cpp/atomic)
+ 线程池
+ 内存池
	+ free为什么只用一个指针
	+ glic内存碎片组织机制和数据结构
	+ https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/

+ C++中的“多态”的概念，简单概括就是“一个接口，多种方法”，是面向对象的一个技术，具体的指相同对象收到不同消息或者不同对象收到相同消息是产生不同的实现动作。

+ SFINAE
	+ `enable_shared_from_this`
+ 多重继承内存分布
+ variant是为了取代union，为什么要取代union，union的用法，variant比union多了什么，variant的实现，为什么不用any，any的实现，variant和visit配套使用，variant实现多态。
+ 菱形继承

### C++和编译

IR和插桩

### C++和汇编

+ C++查虚表使call的是哪个寄存器
+ this指针的传递在汇编层面是怎样的
+ 对象内部有一个field去保存this指针吗？

### C++和Rust

+ 了解Rust的dyn trait吗？如果用C++的元模板变成怎么实现
+ C++怎么实现Rust的Result

# 开放题

+ 矩阵的压缩方式
	+ 对称矩阵，压缩成一维数组
	+ 上三角矩阵或者下三角矩阵，同上
	+ 稀疏矩阵
		+ 三元组顺序表
		+ 行逻辑链接顺序表，添加额外的一个顺序表表示每行第一个非0位置在一维线性表的索引
		+ 十字链表

+ 图片压缩。

+ 英文书籍压缩
	+ 对常用字词进行编码
	+ 哈夫曼编码
	+ 无损压缩
		+ Lempel-Ziv-Welch算法
		+ Deflate算法

# 反问

+ 问做哪个细分方向/业务
+ 分享一下你工作中比较有挑战性/有趣的项目/事情
+ 看中候选人哪些特质
+ 如果是ld一般会问团队后续业务的发展方向和突破口
