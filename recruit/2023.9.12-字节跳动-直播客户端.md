[进度](https://jobs.bytedance.com/campus/position/application?referral_code=8DWH39N)

## 9.17-笔试

万幸，只有编程题。挺好的，都是思维题。

1. 有两个长度为`n`的数组`a[]`和`b[]`，生成一个数组`c[]`，这里`c[i] = std::max(a[i], b[i])`，我们要对`a[]`和`b[]`进行`q`次修改（`a[]`和`b[]`的变化意味着`c[]`也会变换），每次修改是选择`a[]`或`b[]`中的一个数组，然后对它们的两个位置`x`和`y`的元素进行交换。然后对于每次修改，都要输出此时的`c[]`的元素和。这里`1 <= n, q <= 5e4`，`a`和`b`的元素值域在`1e9`以内。
	+ 按照题意模拟即可，维护`c[]`的元素和，每次修改仅仅是变化而不需要重新求和，时间复杂度同`q`
2. 有一个`1e5`长的字符串，下面会给`q`个**短**串（长度不超过10），对于每个询问，给出对应短串在长串中的出现次数。
	+ 预处理字符串中每个长度不超过`10`的字串的个数，大概`10 * n * (10 * log(n * 10))`
	+ 每次询问直接去哈希表中查找即可
3. 有两个长度为`n`的数组`a[]`和`b[]`，我们要选择一个**实数**生成数组`c[]`，即`c[i] = mul * a[i] + b[i]`，我们要找到一个方案（`mul`的选择）使`c[]`中`0`的个数最多，输出这个最多的个数即可。这里`1 <= n <= 1e5 and -1e9 <= a[i], b[i] <= 1e9`
	+ 如果`c[i]`是`0`，则 $ mul = - \farc{b[i]}{a[i]} $，因为实数可能有浮点误差，我们以`std::tuple<int, int, int>`来存储每个有效的`a[i]`和`b[i]`，元组的前两个元素是对应的`a[i]`和`b[i]` **约分** 后的值，第三个元素表示符号
	+ 特判两种情况，
		+ 如果`a[i] == 0`，此时`c[i]`和`b[i]`相关，则`a[i] == 0 && b[i] == 0`的情况单独处理，添加到最后的答案上
		+ 如果上面的情况没有发生，同是`b[i] == 0`，我们发现此时如果`mul`取`0`而无论`a[i]`是何值都是`0`，这样不会被哈希表统计，单独处理。

4. 给三个长度都是`n`的数组`a[], b[], c[]`，在给一个数字`k`，我们要选择三个数组的前缀（子数组），使三个子数组的长度和为`k`，这里长度可以是0，然后对于选择的三个子数组，将其元素全都**或**起来。我们要找到一个选择方案使这个结果最大，输出结果即可。这里`1 <= n <= 1e5, k <= 3 * n`，元素的值域在`int`中。
	+ 我们发现一个数组中，对于这个数组的某个前缀的或和中，只有某个位的第一个出现的位置起关键作用。所以我们只需要拿到一个数组中的在`int`的每一个二进制位中第一个出现的位置就行，后面的都不关键。这样每个数组最多有`32`个可能，然后我们没有三个数组的这个值的所有组合（`32 * 32 * 32`），取合法的，然后将每个数组中第一次出现小于额。。啊吧啊吧的或起来，取最大。
