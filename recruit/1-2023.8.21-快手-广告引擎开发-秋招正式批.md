## 8.25-邀请面试 | 8.28-面试 | 8.28-挂

>再KPI也要认真复盘

1. 询问是否让录屏
2. 自我介绍

+ 介绍在网易工作，遇到什么问题、怎么解决的。
	+ 核心工作是主要负责一款量化交易系统的开发，起初让我负责时是以为可以在已有的开源项目基础上进行二次开发，但是实际上在我调研之后，发现并没有开源的针对“轮询式”策略的量化交易系统。所以我面对的一个问题就是我负责东西的难度可能是超过主管的评估的，因为相当于自研一种量化交易系统嘛，那解决方法只能硬着头皮上，这个过程高频的和策略的同事沟通，遇到问题也及时的和主管沟通。
	+ 那么我最后实现的都有哪部分呢？一个是给用户的接口，即用户写策略代码需要的获取市场信息、和市场交互的函数，这部分使用第三方的平台API封装。然后我们整个产品是系统连同策略一起卖给用户，用户将其部署在它自己的服务器上，所以这里还有一个后端，即前端展示策略打的日志。再一部分就是回测系统了。
	+ 然后提到回测系统了，我刚才说，市面上没有针对轮询式策略的回测系统，我觉得就是因为其不好实现。
		+ 最普遍的是事件式的，直接把整个系统解耦出来，一个事件驱动引擎，一个网关。它是通过设置一个基类从而在语法层面限制，或者说定位用户能实现什么函数，然后直接将函数挂到事件驱动引擎中，然后网关会在发生固定事件时向事件驱动引擎发信号，然后引擎调用，策略和市场的交互因为通过网关。在实盘交易上，轮询式反而要简单，因为针对的是数字货币，它的波动更频繁嘛，怎么实现轮询呢？就是Sleep，用户的策略代码在循环中进行Sleep不就实现了轮询嘛。
		+ 那么到回测这里，难度就反过来了，此时事件驱动模式的几乎不用变，只需要额外提供一个市场模拟，市场模拟在对应事件将信号给网关，对于网关发来的查询和修改也进行变换。其他的部分根本不用动。但是轮询式的不能这样做，因为数据上事件点的移动在策略代码里，回测部分不能自主的进行移动。没有什么参考资料，这个也是我面面临的另一个重要问题。
		+ 最后我采用的方式时，通过这个`Sleep`，在回测时候，系统提供的函数，这里的`Sleep`和网络接口对接回测系统内部，回测系统调用策略代码，当策略代码使用我提供的任何接口时，就运行我们内部的代码，如果是`Sleep`，就移动数据。这个很像操作系统中的用户态和内核态的切换。

+ 怎么解决性能问题

+ 什么是回测？
	大概科普下

+ 回测时间的有序性是怎么保证？
	>我在介绍时没有说清

+ 在Python中因为没有多线程，都是线性的运行性能问题怎么办？

+ Redis的Modern C++实现：
	+ 什么是RAII
		这里留一个相对Class的说法：是C++的一种资源管理技术（比如管理堆内存、文件局部、互斥锁），其基本思想是使用对象的构造函数获取资源（如内存、文件句柄、互斥锁等），并在对象的析构函数中释放这些资源。通过这种方式，可以确保资源在使用结束后被正确地释放，从而避免内存泄漏和资源泄漏等问题。

+ Redis的TTL是怎么实现的？
	首先是在内部维护一个堆，表示一个键要销毁的时间，然后服务器在闲时会不断的轮询堆，如果堆顶的事件早于当前的时间了，说明它该销毁了，于是销毁。  
	然后为了放置一个时间有比较多的键同时销毁，每次轮询是有次数上限的，就是在一次轮询实际有很多很多的键销毁，只会标记，而不真的销毁。因为销毁是服务器就不能响应，这里是为了放置服务器卡住。
	同时这个销毁过程是交给另一个线程去做的。
	>但是我面试时记错了，我说的是新的请求来是检测其是否过期，就是这个时候按照这个时间去清理堆中的键。

	+ 所以就是如果一个我设置了，但是不会再访问，那这部分空间不就一直占用内存么？
	+ 那Redis这部分是怎么实现的？
		Redis是将其额外存在哈希表上的
		+ 惰性删除：只删除当前的查询的键，防止删除其他的键话费CPU时间，但是对内存不友好，即在Get和Put时操作
		+ 定期删除：
	+ 如果是异步删除，具体的策略是什么？
		>面试官期待的答案应该就是上面的

+ 写代码：一个函数，函数头类似：`Node* solve(Node* head, Node* inter)`，head是一个列表的头结点，inter指向这个链表中的一个结点指针，从链表中删除这个结点，然后返回删除后的链表的头结点，**考虑所有边界情况**
	+ 我最开始：
		```cpp
		struct Node {
			int data;
			Node* next;
		};

		Node* solve(Node* head, Node* inter) {
			// [] []: 空链表删除空指针
			// [...] []: head不空, 但是inter空，相当于不删除
			// [] [...]: 在一个空链表上删什么，认为用户误操作
			if (head == nullptr || inter == nullptr) return head;
			// 那么剩下的情况就是至少都是非空的
			// 还有一个可能是inter不在链表上
			if (head == inter) return head->next;  // 特判
			Node* last = nullptr, *node = head;
			while (node != nullptr && node != inter) {
				// node一直往下走，走到末尾或者找到inter
				last = node;
				node = node->next;
			}
			if (node == inter) {
				// 找到inter, 说明inter真的在head的链表上, 此时last刚好就是inter的前一个
				// 这里就出现一个问题就是如果head==inter呢？于是我在开头补了一行特判
				last->next = inter->next;
				delete inter;  // 防止内存泄露!
			}
			return head;
		}
		```

		这个应该是一个比较稳妥的写法

	+ 然后面试官问我有没有性能更高的写法？提示我我们有两个结点的指针，可以直接修改对应内存的东西，于是有了第二个有问题的写法
		```cpp
		Node* solve(Node* head, Node* inter) {
			if (head == nullptr || inter == nullptr) return head;  // 同上
			if (head == inter) return head->next;  // 同上
			auto next = inter->next;  // inter肯定有值
			if (next == nullptr) {
				// inter is tail, or inter is not on head
				// hiki: 这种情况暴力, 这样整个函数均摊O(1)
			} else {
				*inter = *next;
				delete next;  // 防止内存泄露
			}
			return head;
		}
		```
		当面更没有像上面写的那样全面，面试官就走了，40分钟，笑死。

+ 总结：
	+ 对于常见问题可以总结归纳从而实现面试中的更好的表现。
	+ 说话还是着急，速度太快，会结巴，而且思路不好。
	+ 语气好像不太好（虽然不是故意的）

+ 挂复盘：
	1. 回答啰嗦：RAII的回答是从栈和堆空间开始说起的，没有提纲挈领的说清
	2. 手撕代码没有撕好，暴力写法应该还有边界情况，优化写法没有理清空间释放步骤

	总结，挂的该
