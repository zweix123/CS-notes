+ 上课题目和工具：[algorithm coach toolkit](https://github.com/zweix123/ACT)
+ 算法或数据结构模板：
	+ 最大公约数GCD
		```cpp
		int gcd(int a, int b) {
			if (b == 0) return a;
			return gcd(b, a % b);
		}
		```
	+ 快读
		```cpp
		int read() {
			int res = 0, k = 1;
			char c = getchar();
			for (; c < '0' || c > '9'; c = getchar())
				if (c == '-1') k = -1;
			for(; c >= '0' && c <= '9'; c = getchar())
				num = num * 10 + c - 48;
			return k * num;
		}
		```
	+ 快速幂
		```cpp
		int fpow(int b, int n, int m) {
			int res = 1;
			for (; n; n >>= 1, b = 1LL * b * b % m)
				if (n & 1) res = 1LL * res * b % m;
			return res;
		}
		```
	+ 二分
		```cpp
		int l, r, ans = ;
		while (l <= r) {
		    int mid = l + r >> 1;
		    if (check(mid)) l = mid - 1, ans = mid;
		    else r = mid + 1;
		}
		```
	+ 双指针
	+ 单调栈
	+ 埃氏筛素数
		+ 常规： $O(sqrt(n))$ ->  $O(n \times sqrt(n))$

		```cpp
		// 2 -> 4, 6, 8, 10   | n / 2 
		// 3 -> 6, 9, 12, 15  | n / 3
		// ...                  
		// 1 ~ N
		int primes[N], cnt;
		bool st[N];
		void pre() {
		    int limit = N;
		    st[1] = true;
		    for (int i = 2; i < limit; ++ i) if (! st[i]) {
		        primes[cnt ++] = i;
		        for (int j = 2 * i; j < limit; j += i) st[j] = true;
		    }
		}
		```

	+ 前缀和：
		+ 一维前缀和
			```cpp
			// a[], pre[]
			for (int i = 1; i <= n; ++ i) pre[i] = pre[i - 1] + a[i];
			```
		+ 二维前缀和

+ 能喊得出名字的题目：
	+ 最长上升子序列：[洛谷](https://www.luogu.com.cn/problem/B3637)

+ 专题：
	+ 复杂度计算：
		+ `T(n)`是规模为`n`的一个问题的运行时间
		+ $\Theta(1)$表达式常量时间
			>渐进紧确界
		+ 大O记法：`O(...)`：渐进上界
		+ 方法：
			1. 递推式：从含义出发，画树求和
	+ 链表
	+ 表达式

## 浙江CSP-J初赛选择填空题题型

+ CSP规章
+ 数学
	+ 组合数学：高中
	+ 概率论
	+ 逻辑
+ 算法：
	+ 递归模拟
	+ 数据结构
		+ [x] 哈夫曼编码
			+ 完全二叉树
			+ 只有叶子表示字符
			画出完全二叉树，使之叶子结点个数和字符集相同，  
			按频率顺序填充叶子内容。
	+ 简单算法

+ 计算机科学基础
+ 计算机技术基础

>桶和标记数组

## 浙江CSP-J2022初赛

+ `5`：知识点：队列是先进先出，所以队列的出队顺序就是进队顺序，那么题目就转换成给栈的一个进出情况，求其需要求最小容量，模拟即可。
+ `10`：知识点：经典面试题，用两个栈模拟一个队列
+ `12`：排序的稳定性是指的是，比如`x`位和`y`位的元素值是相等的，那么排序后它们的相对位置不变
+ [ ] `17`：
+ `18`：
	+ `solve1`：二分法求`sqrt`
	+ `solve2`：参数为double的多次进行`x = (x + n / x) / 2`
		+ n is int: `sqrt(n)`
		+ else: 浮点数误差->模拟
+ [x] `20`：广搜

## 浙江CSP-J2021初赛

+ `16`：二进制魔法
+ [ ] `17`
+ [ ] `19`
+ [ ] `19`：Josephus问题
+ [ ] `20`：矩阵计数

## 浙江CSP-J2020初赛

+ `16`：一种简单的加密算法实现
+ `17`：代码阅读：模拟`k`进制数字不断`+1`加了`n`次的进位次数
+ `18`：代码阅读：旅行商问题暴力，NP问题
	代码如下：
	```cpp
	#include <iostream>
	#include <algorithm>
	
	using namespace std;
	
	int n, d[50][2], ans;
	
	void dfs(int n, int sum) {
	    if (n == 1) {
	        ans = max(ans, sum);
	        return ;
	    }
	    for (int i = 1; i < n; ++ i) {
	        int a = d[i - 1][0], b = d[i  - 1][1];
	        int x = d[i][0], y = d[i][1];
	        d[i - 1][0] = a + x;
	        d[i - 1][1] = b + y;
	        for (int j = i; j < n - 1; ++ j)
	            d[j][0] = d[j + 1][0], d[j][1] = d[j + 1][1];
	        int s = a + x + abs(b - y);
	        dfs(n - 1, sum + s);
	        for (int j = n - 1; j > i; -- j)
	            d[j][0] = d[j - 1][0], d[j][1] = d[j - 1][1];
	        d[i - 1][0] = a, d[i - 1][1] = b;
	        d[i][0] = x, d[i][1] = y;
	    }
	}
	
	int main() {
	    cin >> n;
	    for (int i = 0; i < n; ++ i) cin >> d[i][0];
	    for (int i = 0; i < n; ++ i) cin >> d[i][1];
	    ans = 0;
	    dfs(n, 0);
	    cout << ans << "\n";
	    return 0;
	}
	```
+ `19`：代码填空：质因数分解
+ [ ] `20`：代码填空：最小区间覆盖

## 浙江CSP-J2019初赛

+ `16`：阅读题目，简单程序
+ [ ] `17`：代码如下：
	```cpp
	#include <iostream>
	const int N = 100;
	int n, m, a[N], b[N];
	int main() {
	  std::cin >> n >> m;
	  for (int i = 1; i <= n; ++i) a[i] = b[i] = 0;
	  while (m--) {
	    int x, y; std::cin >> x >> y;
	    if (a[x] < y && b[y] < x) {
	      if (a[x] > 0) b[a[x]] = 0;
	      if (b[y] > 0) a[b[y]] = 0;
	      a[x] = y;
	      b[y] = x;
	    }
	  }
	  int ans = 0;
	  for (int i = 1; i <= n; ++i) {
	    if (a[i] == 0) ++ans;
	    if (b[i] == 0) ++ans;
	  }
	  std::cout << ans << "\n";
	  return 0;
	}
	```

	疑似和双向链表有关，但是不清楚，不过题目只要求阅读题目回答问题，颅内编译即可。
+ `18`：代码阅读
	+ 对于一个数字，递归，每次找到第一个最小值，左右分两半，返回左边结果+右边结果+当前深度乘最小值，深度从1开始、
	+ 有一个冗余的数组

+ [ ] `19`：代码填空，变换矩阵：
	+ `0`变成
		```
		0 0
		0 1
		```

	+ `1`变成
		```
		1 1
		1 0
		```

	+ 矩阵初始为`[0]`

	问若干次变换后的矩阵（显然结果唯一）

	递归的经典妙用

+ [ ] `20`：双关键字计数排序：
	+ 先处理第二关键字，再处理第一关键字
	1. 统计数字出现次数
	2. 对统计的桶进行前缀和
	3. 此时遍历数组，数组在前缀和中的值就是其最后的次序，这个结果放在一个数组中
	+ 那么怎么统筹两个关键字呢？再处理究竟是什么样子的？  
		在上面的第三部我们是通过下标遍历的原数组，而现在我们得到了一个新的数组，它是对应元素的新下标，那么再以这个假装是其下标再进行一次

	```c
	// 按照字节进行填充
	memset(起始地址, 填充的字节, 填充字节的数量);
	// 只能填充-1, 0, 某个很大值
	// 0 -> 
	// -1 -> 111111 -> 1 * 32
	// 0111111 -> 0111111011111101111110111111 
	```

## 浙江CSP-J2018初赛

+ `18`：简单程序
+ `19`：简单模拟程序
+ `20`：简单模拟递归
+ `21`：模拟
+ `22`：按照题目简单实现
+ `23`：对于一个排列`P`，生成一个新的数组`Q`，其中`Q[i]`表示从`i`开始向后第一个大于`P[i]`的元素的位置，无则是一个特殊值
	+ 单调栈：栈元素为索引，对于新的元素，将栈中小于自己的全部都弹出并修改对应答案，编译完之后将栈中设置为特殊值
	+ 双向链表实现：

## 浙江CSP-J2017初赛

+ `21`：统计输入字符串只出现一次的字符
+ `22`：递归模拟
+ `23`：理解题目，其所求为一个01串，遍历每个位置，该位置以前（不包含该位置）的1的个数和该位置以后（包含该位置）的0的个数的和
+ [ ] `24`：
	```cpp
	#include <iostream>
	using namespace std;
	
	int main() {
	    int n, m;
	    cin >> n >> m;
	    int x = 1, y = 1;
	    int dx = 1, dy = 1;
	    int cnt = 0;
	    while (cnt != 2) {
	        cnt = 0;
	        x = x + dx;
	        y = y + dy;
	        if (x == 1 || x == n) {
	            ++ cnt;
	            dx = -dx;
	        }
	        if (y == 1 || y == m) {
	            ++ cnt;
	            dy = -dy;
	        }
	    }
	    std::cout << x << " " << y << "\n";
	    return 0;
	}
	```
	+ 输入`4 3`求输出
	+ 输入`2017 1014`求输出

+ `25`：快速幂
+ `26`：经典二分答案

## 浙江CSP-J2016初赛

+ `23`：代码阅读，不断输入整数，遇到0则停止，输出个数、极值
+ `24`：代码阅读
+ `25`：代码阅读，反转数组。
+ `26`：代码阅读，忽略大小写的字符串比较。
+ [ ] `27`：代码填空，快读实现。
+ `28`：代码填空，`n`个学生去郊游，每个人有钱，也有一个总经费，然后要租车，每个车子价格不同。互相之前不能借钱，即每个人只能用自己的总经费。
	+ 二分答案，Check：钱最多的一批买最便宜的一批车子，这里面怎么处理呢？**先让钱多去买最便宜的**，然后这个过程记录需要的额外的钱，如果钱小于总经费则可以

## 浙江CSP-J2015初赛

+ `27`：代码填空，模拟月历输出
+ `28`：二分数组中位数

## 浙江CSP-J2014初赛

+ [ ] `26`：埃氏筛
+ `27`：简单程序代码填空
+ [x] `28`：最大子矩阵和：不是二维前缀和，而是对每一行都进行前缀和，然后枚举所有的列的范围，对于每个列的范围，枚举每一行，这样就形成了一个矩阵，而这个矩阵的每一行，我们都可以用行前缀和快速求出，问题转变成最大区间和问题。

## 浙江CSP-J2013初赛

+ `22`：对于固定的`s`，给出多组`a`和公式$\sum(s_i \times a_i) mod \ 2$的结果，求`s`序列
	1. $s_1 + s_2 \ mod \ 2 = 1$ -> s1 == 1 or s2 == 1
	2. $s_3 + s_4 \ mod \ 2 = 0$ -> (s3 == 1, s4 == 1) or (s3 == 0, s4 == 0)
	3. $s_2 + s_3 \ mod \ 2 = 0$ ->
	4. ...
	5. s1 -> 0
+ `27`：最长单调子序列：给你一个序列，（子序列），找到最长的单调的子序列（单调）
	+ 子串：是必须连续的  
		```cpp
		// string s;
		for (int i = 0; i < s.size(); ++ i) {
			for (int j = i; j < s.size(); ++ j) {
				// (i, j)
			}
		}
		```

		子序列，可以不连续，先后不变		  


		没有或者是全部是是不是“子”：
	
	+ 最最暴力找子序列：$O(2^n)$
	+ 动态规划：$O(n^2)$
		```cpp
		int f[N];  // f[i] -> 1 ~ i -> 
		for (int i = 1; i <= n; ++ i) {
			// f[i]
			for (int j = 1; j < i; ++ j) {
				// f[j] -> 1 ~ j
				// ... ... a[j], a[i]
				if (a[i] > a[j]) a[i] = max(a[i], a[j] + 1);
			}
			ans = max(ans, a[i]);
		}
		// x .. y
		```
+ `28`：排序重排
	+ 暴力：空间暴力，时间暴力
	+ 三个反转
+ [x] `29`：二叉查找树验证：
	+ [力扣](https://leetcode.cn/problems/validate-binary-search-tree/submissions/460928284/)
		```cpp
		/**
		 * Definition for a binary tree node.
		 * struct TreeNode {
		 *     int val;
		 *     TreeNode *left;
		 *     TreeNode *right;
		 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
		 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
		 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
		 * };
		 */
		 // -1e9 +1e9
		 // 1e10L
		class Solution {
		public:
		    using ill = long long;
		    bool isValidBSTInter(TreeNode* root, ill lower, ill upper) {
		        if (root == nullptr) return true;
		        if (root->val <= lower || root->val >= upper) return false;
		        return isValidBSTInter(root->left, lower, root->val) \
		               && isValidBSTInter(root->right, root->val, upper);
		    }
		    bool isValidBST(TreeNode* root) {
		        return isValidBSTInter(root, std::numeric_limits<ill>::min(), std::numeric_limits<ill>::max());
		    }
		};
		```

## 浙江CSP-J2012初赛

+ `19`：AAABBBCCC的不同字串数量——36
+ `21`：二维平面选择至少多少了点可能保证某两点重点在整数点上

+ `27`：暴力求二维平面若干点，每个点的左下边的点的个数，的最大值
+ [ ] `28`：全排列

## 浙江CSP-J2011初赛

+ `24`：找中位数？，简单模拟
+ `25`：递归模拟
+ `26`：暴力模拟题目：
+ [ ] `27`：代码填空，高精度开方（二分）
	>卧槽，高精

## 浙江CSP-J2010初赛

+ `22`：三个整数数和为8，他们一次入队出队，有多少种队列快照
+ `24`：代码阅读，区间范围内有多少数字的是回文的
+ `25`：代码阅读，递归模拟
+ `26`：代码填空，哥德巴赫猜想范围`n`内验证

## 浙江CSP-J2005初赛

## 浙江CSP-J2022复赛

+ 乘方：快速幂
+ 解密：二元一次方程组
+ 逻辑表达式：给只有`&`和`|`的中缀表达式，给出结果，并计算短路次数
+ 上升点列：二维平面，已有n个点，添加k个点，要让最后可以找到相邻点连接长度最长，n 500 k 100

## 浙江CSP-J2021复赛

+ 分糖果：相当于多组给数字和模数，要余数最大
+ 对于插入排序
	>维护过的部分，有序，然后末尾新元素冒泡到对应位置，比较关键字为`<`而不是`<=`

	给一个数组，两个操作。操作1修改，操作2问数组按照插入排序排序后位置（非持久，每次重排）

+ 网络连接：模拟
	+ 判断地址
	+ 输入为类型和地址
		+ 服务器：不能重复，地址即为其地址
		+ 客户端：地址为目标地址，提供连接到哪里了

+ 一个序列，元素两种类型，同类一块，每次扫描拿出每个块最左边的（所以块会变化）模拟该过程
	+ 暴力双指针：找是`n`、移动是`n`、最差`n`次，故`n`方
	+ 手动模拟分块，使用链表，空则判断左右。
	
## 浙江CSP-J2020复赛

+ 优秀拆分：等价于给出数字的二进制表示
	+ 二进制理解和处理
+ 直播获奖：一组成绩获奖边界为$max(1, \lfloor p \times w \% \rfloor)$，边界成绩相同都可获奖，给一动态的出分情况，输出不同时刻的获奖边界成绩
	+ 模拟
+ 给运算符只有`&`、`|`、`!`的后缀表达式，多次询问，每次暂时修改一个变量的值，求表达式结果  
	变量数量`1e5`、询问`1e5`次

	>每次一算不知道会不会炸

	+ 表达式类型
	+ 如果炸只能建树然后每次在树上跑理论也能卡

+ 方格取数变形，左上到右下，每次移动向右，向上和向下，不可重复走
	+ 我们发现整体向右，所以循环每一列
	+ 然后发现当进入一个列之后，向上就一直向上，向下就一直向下，就是普通的方格取数了
	+ DP变形
