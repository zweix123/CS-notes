# 指令系统

+ 指令周期Instrution Cycle：
  1. Fetch取得指令：指令在内存中，由控制器操作
  2. Decode指令译码：由控制器进行
  3. Execution执行指令：计算在运算器进行，无条件跳转在控制器完成
  4. Store数据回写
+ 指令类型：
  + 数据传输类型：
    + `store/load`：寄存器与内存间数据传输
    + `mov`：内存地址的数据移动到另一个内存地址
  + 运算类型：处理两个寄存器中的数据
  + 跳转类型：通过修改程序计数器中的值打到跳转执行指令
  + 信号类型：
    + `trap`：中断
  + 闲置类型：
    + `nop`：CPU空转一个周期

## 指令格式

**基本格式**：`操作数OP 地址码A`

> 汇编：`A`表示这个地址，`(A)`表示A这个地址上的值

+ 定长指令字结构：指令长度固定

  变长指令字结构：指令长度不等

+ 定长操作码：`n`位：$2^n$条指令

  扩展操作码：指令长度可变

### 地址码

> 一下讨论默认指令32位，操作数为8位

![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/source/Computer-Organization&Architecture/指令格式.jpg)

+ 指令和数据混用：要指出下条指令地址
+ 指令和数据分区：指令自动使用下一个

### 操作码

+ 注意事项：
  + 不能重复
  + 短操作码不能是长操作码的前缀
  + 使用频率高的操作码更短：减少译码时间
+ 扩展操作码：把操作码全1作为指示，然后取地址码进行编码（地址码少1），继续扩展同理
+ 其他说明：![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/source/Computer-Organization&Architecture/指令操作码.jpg)

+ 分类（汇编）：

  ![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/source/Computer-Organization&Architecture/操作码操作类型.jpg)


## 寻址方式

### 数据存放问题

> 一些引入

可以把存储空间想象为一个二维矩阵，其中一行是**字存储单元**，一个小格是**字节存储单元**，一般采用**按字节编址**，即每个字节都要有一个编号

> 大端存储：一个字的信息顺序放在一个字中                    ，利于人读
>
> 小端存储：一个字的信息按字节分块逆序放在一个字中，利于机器读

+ 寻址：
  + 按字节寻址：使用字节地址                   ，取出该地址一个字节的信息
  + 按字   寻址：使用字中字节的最低地址，取出该地址开始后一个字的信息

+ 字长：都必须是字节的整数倍

  + 机器字长：CPU一次能处理的信息的二进制位数

  + 指令字长：指令的二进制表达位数

    比如：单字长指令：指令长度=机器字长，同理还有单字长指令，双字长指令

  + 存储字长：

+ 边界对齐存储：

  + ​    对齐：占据存储空间”矩阵“的一行                                              ：一次缓存读出
  + 不对齐：占据存储空间”矩阵“的多行（有些格未被本信息使用）：多次缓存读出（舍弃一部分）

  不对齐方案没必要，都采用对齐方案（如果前边出现空格，新的信息新开一行——空间换时间）

### 指令寻址

+ 指令寻址：定位 下一条 要 执行指令 的 指令地址

  使用由程序计数器PC给出

  1. 普通指令：顺序寻址：`(PC) + 1 -> PC`
  2. 跳转指令：跳转寻址：比如`JMP 地址`：把PC改为地址

### 数据寻址

> 操作数类型：地址：无符号数（在某个位置取一个数字作地址）、数字：定点数、浮点数、十进制数（BCD码）、字符：ASCII码、逻辑数：逻辑运算

+ 指令结构：以一地址指令为例：`操作码OP 寻址特征 形式地址A`：寻址特征和形式地址A一起指出操作数的实际地址(有效地址EA)

下面讨论不同寻址特征的处理方式：

| 寻址特征       | 说明                                                         | 优点                                       | 缺点                           | 指令执行访存次数               |
| -------------- | ------------------------------------------------------------ | ------------------------------------------ | ------------------------------ | ------------------------------ |
| 立即寻址       | 形式地址A就是操作数本身<br>又称立即数                        | 不访问主存<br>快                           | A的位数限制<br>立即数的大小    | 1：取指令                      |
| 直接寻址       | 形式地址A就是有效地址<br>`EA = A`                            | 简单                                       | 较于间接寻址<br>操作数不能修改 | 2：取指令<br>      执行指令    |
| 间接寻址       | 形式地址A指出的是操作数的地址<br>`EA = (A)`<br>多次间址：存储空间设置标志位 | 扩大寻址范围<br>便于编制程序（子程序返回） | 慢                             | 3：取指令<br/>      执行指令*n |
| 寄存器寻址     | 形式地址是寄存器中的地址`EA = Ri`                            | 快，短，支持向量运算                       | 贵                             | 1                              |
| 寄存器间接寻址 | `EA = (Ri)`                                                  |                                            | 指令的执行过程中可能访问主存   |                                |
| 隐含寻址       | 不明显给出操作数的地址，而是默认隐含                         | 短（连地址都不用）                         | 需要多余的硬件                 |                                |

+ 偏移选址：`EA = (...) + A`：从某个（寄存器的内容）往后偏移，这里的区别是寄存器的特点，访存次数是1

  > 基址寻址用于整个迁移程序，变址寻址用于循环，相对寻址用于跳转

  + 基址寻址：将CPU中**基址寄存器BR**的内容加上指令格式中的形式地址A：`EA = (BR) + A`。

    > （这里的加法可以把BP中的值和A作为ALU的输入，然后把输出作为EA）

    + 采用通用寄存器作为基址寄存器：在指令的寻址特征和形式地址A中指出寄存器的地址（相当于采用专用寄存器是隐含寻寄存器的址）

    > 基址寄存器是==面向操作系统==，==其内容由操作系统或管理程序确定==，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）

    + 采用通用寄存器作为基址寄存器，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定

    优点：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）

    + 利于多道程序设计：同样的程序，在不同的内存块运行，并不需要把里面所部的地址都修改，而是修改起点，程序内保证相对位置就好

  + 变址寻址：使用**变址寄存器IX**

    + 变址寄存器是==面向用户==的，在程序执行过程中，==变址寄存器的内容可由用户改变==（作为偏移量），形式地址A不变（作为基地址）

      > 与基址寻址相反

    + 优点：扩大寻址范围
      + 适于编制循环程序：循环中对数组的迭代（因为是连续的），可利用IX的自增，而不需要每次都修改形式地址A

  + 相对寻址：把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址`EA = (PC) + A`，其中A的相对与当前指令地址的偏移量，可正可负，补码表示

    + 优点：浮动
    + 利于跳转指令：以当前运行的指令所在的内存为基准进行相对跳转

+ 堆栈寻址：使用堆栈指针寄存器`SP`，运行逻辑和数据结构栈同

  + 硬堆栈：在寄存器空间的栈

    软堆栈：在主存空间的栈

## 设计方向

1. Complex Instruction Set computer, CISC：复杂指令集
   + x86架构，主要用于笔记本、台式机

> 80-20规律：典型程序中80%的语句仅仅使用处理及中20%的指令

2. Reduced Instruction Set Computer, RISC：精简指令集
   + ARM架构，主要用于手机、平板

![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/source/Computer-Organization&Architecture/指令集.jpg)
