
## 策略编程范式对回测系统开发的影响

>用户可能需要的交易方式包含实盘交易、模拟盘交易和回测，最好的方式肯定是“一套代码、处处运行”

+ Pre：
	+ 网关Gateway/客户端Client Etc.：因为所有的交易本质都是向网站发送网络请求，不同的系统有各自的封装，不同系统的称呼不一样。这里统称网关

现在考虑怎么解决一套代码，在实盘交易和回测中都正常运行呢？发挥想象力的说可以把网关做成阴阳壶，在实盘交易中正常发网络请求，在回测中则将其对接内部的回测系统。

### 基于事件驱动

事件驱动引擎Event Engine：它的功能是，如果发生什么**事件**、则会调用什么**函数**。这里的事件和对应的函数是可以由外界向里注册的。这些事件的检测和调用都是自动的。  
事件驱动引擎通常作为交易系统的内核之一，由系统开发者手动将特定的事件注册进去，然后想办法让用户实现这些事件对应的函数，从编码的角度实现这样的目的的方案之一就是通过继承。  
所以基于事件驱动的系统的策略编写范式通常是让用户继承它提供的基类，这样的语法层次就限制了用户必须要实现什么方法，从而保证事件驱动引擎一定有哪些事件对应的函数。

这些被基类“限制”的方法，就是系统给到用户的权利，同时用户也只有这些权利，用户的代码是被限制的，必须实现哪些方法，也只能实现这些方法，这些方法也只能在规定的时间被调用。

所以这类平台的实盘交易模式是下面这样的  
<img alt="事件驱动交易系统运行模型" src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Quant/event-model-real.png" style="width:42%" >
网关不断的监控市场，在检测到某些事件的发生时，则告知事件驱动引擎，继而自动的运行策略中的代码，而代码中的逻辑也通过网关和市场进行交互

该模型的好处是实现了用户代码的复用，在回测部分不需要修改用户的策略代码，网关直接变身阴阳壶，在回测时不对接真实的市场，而是对接自己的“市场模拟程序”，也就是回测系统，其他的什么都不需要变化。因为事件驱动引擎不知道自己是因为哪里来的事件而驱动。这样回测系统只需要“自顾自”的模拟数据，在发生对应事件时告知网关，然后和网关进行交互。  
但是这个过程似乎没有那么解耦？因为回测系统要和网关交互，难道要等策略进行决策嘛？不是的，因为用户的行为不会影响市场数据（比如一个人会下巨大的单继而影响市场价格？），所以回测系统只需要不断的产生数据（包括事件），用户策略只需要（通过事件驱动引擎）依次执行即可，然后其行为通过独立的（是回测系统中独立的子模块）账户资金管理进行处理即可。
<img alt="事件驱动交易系统运行模型" src="https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Quant/event-model-backtest.png" style="width:42%" >

### 发明者模式

发明者是有`Sleep`内置函数，同时`.com`的发明者是主要针对数字货币的量化交易的，数字货币较于股票的明显区别是价格是连续的，可以24小时交易。所以这里的市场的事件较于股票少一些，更多的针对数字货币的交易是**轮询式**的，即周期性的轮询市场，通过价格变动进行决策。

这样的策略代码较于基于事件类型的更加灵活，因为不用一定要继承某个类，代码风格、编程范式更多。

>那么代价是什么呢？

我们发现上面的系统模型不灵啦，回测系统不能自顾自的模拟数据，必须和策略进行交互，且必须知道策略什么时候`Sleep`，它的数据的变化也是因为`Sleep`而发生的。上面的模型中回测系统根本不知道策略做了什么，而现在的情况它必须知道里面在什么时候运行了`Sleep`，这怎么实现呢？
