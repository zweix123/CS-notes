# Virtual Menory
>对应Physical Memory
>
>操作系统提供的“抽象”之一

+ 问题：
+ 目标：
	+ 高效：性能开销，物理资源
	+ 安全：隔离性
	+ 透明：抽象成本

+ 在CPU完成虚拟内存到物理内存的**地址翻译**，相关硬件如下：
	+ Memory Management Unix, MMU内存管理单元：负责翻译
	+ Translation Lookaside Buffer, TLB转址旁路缓存（MMU内部单元）

## 地址翻译机制

### 分段机制
>现代操作系统并未广泛应用

+ 问题：外部碎片

### 分表机制


+ 单级页表：将虚拟地址划分为连续的、等长的的虚拟页（区分于分段机制中不同长度的段）
	+ 页表：虚拟页到物理页的映射关系
	+ 虚拟地址结构：虚拟页号和页内偏移量
	+ 流程：从页表基地址寄存器找到页表，然后去页表中找到对应的物理页

+ 多级页表：
	+ 问题：单级页表机制的页表非常的大，而且在页表中每个虚拟页到物理页的映射必须存在（因为页表可被看作地址）
	+ 解决：引入多级页表，低级页表仍然是每个映射都存在的数组，但是它体积变小了，可以存在，而高级页可以暂时不存在，只有使用时才存在。

+ 流程：首先去TLB查看是否缓存，如果有，则为Hit，得到物理地址；否则逐级翻译虚拟地址得到物理地址

## TLB

+ 发心：多级页表显著降低页表大小，但是导致地址翻译时长增加，即翻译在依次查找多个页表页是可能导致多次物理内存访问，通过TLB减小地址翻译次数。

+ 结构：![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Operating-System/TLB-structure.png)

+ 刷新：每次操作系统在页表切换（应用程序切换）时，会刷新TLB（来避免缓存错误）
	+ 在系统调用过程中，从用户态切换到内核态，这也是一种“程序切换”，操作系统自己的数据也存在内存中，怎么处理？
		+ AArch64体系结构上有`TTBR0_EL1`和`TTBR1_EL1`两个页表基地址寄存器，后者由操作系统使用，故操作系统有自己的页表，避免了TLB的刷新。
		+ x86-64体系结构上只有一个页表基地址寄存器`CR3`，操作系统通常不使用单独的页表，而且将自己映射到应用程序页表中的高地址部分，也不需要刷新TLB

	+ 但是每次都刷新还是有太多开销了，可以为缓存项打上“标签”，在使用时通过应用程序和标签匹配来区分新旧缓存，从而不用刷新
	+ 同时当修改页表内存时，也应该刷新TLB，
		+ AArch64体系结构提供多种不同的粒度刷新TLB，以获得更好的性能。

## 换页与缺页异常
>page swapping and page fault

如果虚拟页没有被分配使用，则页表中自然没有其相应的物理内存，但是被分配使用的虚拟页在页表中一定有么？也不是。

虚拟内存是操作系统重要的抽象，而且虚拟内存的目标之一就是透明性。比如操作系统可以让多个内存和大于机器内存的程序一起运行。

使用的就是换页机制，将内存页不够时，将若干物理页写到磁盘中，回收这些物理页。

1. swap out换出：将物理页对应的虚拟页在其页表中设置为“已分配但未映射至物理内存”状态
2. swap in换入：当访问到这样的虚拟页时，则触发page fault缺页异常，CPU运行操作系统预设的page fault handler缺页异常处理函数，该函数找到空闲物理页，加载信息

### 预取
>pregetching

缺页异常很慢，那么在换入时可以猜测哪些页即将被访问，将它们一并换入物理内存。

### 按需页分配
>demand paging

即在程序申请分配内存时，可以选择将新分配的虚拟页标记为“已分配但未映射至物理内存”，只有触发缺页异常时才分配。从而节省物理内存资源。

+ 因为缺页异常是慢的嘛，所以虽然节省了内存，但是对于内存页来说，初次访问的缺页异常缺导致。一个解决方案是结合预取和按需分配，比如分配的一批虚拟页都是已分配未映射，则在第一个缺页异常时预取一批，避免后面的内存页的缺页。

+ 上面提到两种虚拟页状态？Linux中，将虚拟页分成多个段，然后看一个虚拟页是否在段中，如果在段中，则是未分配，否则则是已分配但未映射。

## 页替换策略

上面提到的换页中，怎么选择哪些页换出呢？


## 虚拟内存功能

+ 共享内存
+ 写时拷贝：在`fork`时去掉页的可写标志，在对其写时触发缺页异常，异常中分配。
+ 内存去重，即遍历所有物理页，找到相同的物理页，对其对应的虚拟页进行类似写时拷贝的设置。比如Linux中的KSM。
	>可能操作被工具，比如对一个页枚举数据，如果发现写它的延迟不同，则说明其被内存去重了，即说明有相同内容的页。一个防御方法是只在应用内存内部去重

+ 内存压缩：将最近不太用的内存压缩，用时解压。较于写入硬盘更快。比如Linux的zswap机制：即提供zswap区域，对换出的页压缩放进该区域，即，减小磁盘IO，或者批量磁盘IO。

+ huge page大页，缓解TLB缓存项不够用的问题
	+ Linux transparent huge page透明大页机制，将小页合并成大页。

## 物理内存分配器
