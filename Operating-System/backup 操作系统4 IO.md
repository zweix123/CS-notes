UNIX系统将外部设备抽象成一种特殊的文件，通过读写和外部设备进行操作

+ 分类：
	+ 按照使用特性分类：
		+ 人机交互类外部设备
		+ 存储设备
		+ 网络通信设备
	+ 按照传输速率分类：
		+ 低速
		+ 中速
		+ 高速
	+ 按信息交换的单位分类
		+ 块设备：传输速率较高，可寻址
		+ 字符设备：慢、不可寻址

+ IO设备：
	+ 机械设备：主要执行具体IO操作
	+ 电子设备：插入主板扩充槽的印刷电子路

对于机械设备，CPU不能直接控制，需要中介——IO控制器/设备控制器：CPU控制IO控制器，IO控制器控制设备

+ 功能：
	+ 接受和识别CPU发出的命令：IO控制器中相应的控制寄存器存储诸如read和write的命令
	+ 向CPU报告设备的状态：IO控制器重有相应的状态寄存器用于记录IO设备的当前状态
	+ 数据交换：IO控制器中会设置相应的数据寄存器
	+ 地址识别：上面数据交换中的地址
+ 组成：![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Operating-System/IO控制器.jpg)

1. 一个IO控制器可能对应多个设备
2. 数据、控制、状态寄存器可能有多个，它们都需要相应的地址

+ 地址的处理：
	1. 把其作为内存地址的一部分——内存映像IO：IO控制器中的寄存器和内存地址统一编址
	2. 采用IO专用地址——寄存器独立编址：需要专门的指令，而且地址中处理寄存器的地址还需要包括是哪个IO控制器的

## IO控制方式

1. 程序直接控制方式：
	1. CPU向控制器发送指令，
	2. 控制器启动设备并将状态寄存器中标记
	CPU**Polling轮询Key word检查**控制状态（不断地执行某个程序）
	3. 设备可以使用后，告诉数据寄存器，修改状态寄存器，CPU即可知道从可以从对应数据寄存器读到数据
	4. 存入存储器
	+ 每次送一个字的数据
	+ 本质是内存和IO之间地交换，CPU做中介
	+ 缺点是CPU必须不断运行
2. 中断驱动方式：中断机制，将等待IO地进程阻塞。IO完成后向CPU发送信号，CPU检测到中断信号，进行处理
	+ CPU在每个指令周期末尾检测
	+ 中断处理需要保存、恢复进程，这个是有开销地
	+ 每次读一个字
	+ 可CPU和IO并行
	+ 缺点：如果中断过于频繁
3. DMA Direct Memory Acess直接存储器存取方式
	+ 传送单位是块，不是一个字
	+ 数据是设备和内存地直接交换
	+ 需要CPU的干预很好，只在传送一个或多个数据块的开始和结束才有
	![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Operating-System/DMA控制器.jpg)
4. 通道控制方式：![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Operating-System/通道.jpg)
	1. CPU向通道发送指令
	2. IO完成后PCU中断
	+ CPU的干预频率低很多，因为可以给通道一系列的命令，只有中断需要专门停止
	+ 数据传输单位：
## 软件层次
>下面的2、3、4属于操作系统内核部分，即IO系统（IO核心子系统）
1. 用户层软件：实现与用户交互的接口
2. 设备独立性软件/系统调用输出层：
	+ 为上层提供接口
	+ 设备保护：区分权限
	+ 差错处理
	+ 设备的分配与回收
	+ 设备缓冲区管理
	+ 建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序：  
		通过逻辑设备表LUT，Logical Unit Table：逻辑设备名、物理设备名、驱动程序入口程序
		+ 整个移动一张LUT：使用于单用户
		+ 为每个用户设备一张LUT
3. 设备驱动程序：对硬件设备进行具体控制，即将上层的命令转化成设备的指令（所以才需要不同的设备驱动程序）
4. 中断处理程序：处理中断：
5. 硬件

+ 设备独立性软件层次：
	1. IO调度：各种调度算法
	2. 设备保护：看作特殊文件

### 假脱机技术
SPOOLing技术
+ 脱机技术，一种脱离主机控制的IO：在外围控制器的控制下，慢速设备将数据先输入到更块的磁带上，然后从磁带读入数据，反之亦然
+ 假脱机技术：在内存中建立两个缓冲区，输入缓冲区和输出缓冲区，由输入程序和输出程序管理  
	在磁盘中还有输入井和输出井它们和缓冲区交互
	+ 在井中申请空闲缓冲区，并把数据放里面
	+ 为进程申请一份请求表将其放在假脱机文件队列，
	+ 设备空闲则会从队列中找

## 设备分配

+ 分配时要考虑的因素：
	+ 设备的固有属性
		+ 独占设备
		+ 共享设备
		+ 虚拟设备
	+ 设备分配算法：调度
	+ 设备分配中的安全性：
		+ 安全分配方式：进程分配设备后阻塞、本次IO完成才唤醒
			+ 不会死锁
			+ IO和CPU只能串行
		+ 不安全分配方式：为进程分配IO后进程继续执行

+ 静态分配：进行运行前为其分配全部所需的资源，运行结束后归还资源
+ 动态分配：进程运行过程中动态申请设备资源

+ 数据结构：
	>一个通道可以控制多个控制器，而一个控制器需要多个设备
 
	+ 设备控制表DCT：为每个设备配置一张DCT，记录设备的情况
		+ 设备类型：
		+ 设备标识符
		+ 设备状态
		+ 指向控制器表的指针
		+ 重复执行次数或事件：多次执行IO都失败认为此次IO失败
		+ 设备队列的队首指针：指向正在等待设备的进程队列（由进程PCB组成的指针）
	+ 设备控制表COCT：OS根据COCT的信息对控制器进行操作和管理
		+ 控制器标识符：控制器的IO
		+ 控制器状态
		+ 指向通道表的指针
		+ 控制器队列的队首指针
		+ 控制队列的队尾指针：
	+ 通道控制表CHCT：
		+ 通道标识符
		+ 通道状态
		+ 与通道连接的控制器表首地址
		+ 通道队列的队首指针
		+ 通道队列的队尾指针
	+ 系统设备表SDT：记录系统中全部设备，由表目组成，每个表目：设备类型、设备标识符、DCT、驱动程序入口

+ 设备分配的步骤：
	1. 根据进程请求的物理设备命查找SDT
	2. 根据SDT找到DCT
		+ 设备忙碌则将进程PCB挂到控制器等待队列
		+ 不忙碌则将设备分配给进程
	3. 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列，不忙碌则控制器分配进程
	4. 根据COCT找到CGCT，若通道忙碌则将进程PCB挂到通道等待队列，不忙碌则分配通道
	+ 这里需要物理设备名，但是对用户透明，不能编程——建立逻辑设备名和物理设备名的映射机制 
	+ 这时第一步就是提供逻辑设备名，然后SDT找到用户进程指定类型的、空闲的（在逻辑设备表LUT中新增一个表项）  
		这样的问题是，系统只有一个张LUT，即逻辑设备命不能重名，所以为每个用户都设置一个LUT

## 缓冲区管理
>硬件缓冲区好用，但是成本高、容量下，下面讨论以内存作为缓冲区
+ 缓冲区的作用：
	+ 减少CPU和I/O设备之间速度不匹配的矛盾
	+ 减少对CPU的中断频率，放宽对CPU中断相应时间的限制
	+ 解决数据粒度不匹配的问题
	+ 提高CPU与I/O设备之间的并行性
+ 缓冲区管理策略：
	+ 单缓冲：缓冲区非空则不能读，反之亦然
	+ 双缓冲：
	+ 缓冲池：多个缓冲区，用时拿出

+ 缓冲池分类：
	+ 按缓冲区使用情况分类：
		+ 空缓冲队列	
		+ 输入队列
		+ 输出队列
	+ 按功能不同分配：
		+ 收容输入数据的工作缓冲区hin
		+ 用于提取输入数据的工作缓冲区sin
		+ 用于收容输出数据的工作缓冲区hout
		+ 用于提取输出数据的工作缓冲区sout