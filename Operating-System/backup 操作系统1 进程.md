## Intro

+ 进程实体/进程映像（广义上的进程）：由PCB（存储程序的信息）、程序段、数据段组成
  + PCB是进程存在的唯一标志
    + 进程描述信息
      1. 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符
      2. 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务
    + 进程控制和管理信息：
      1. 进程当前的状态：new、ready、running、waiting、blocked
      2. 进程优先级：进程抢占CPU时的优先级
    + 资源分配清单：
      1. 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的IO设备信息
    + CPU相关信息：
      1. CPU中各个寄存器的值
  + PCB怎么组织：通过链表：把具有相同状态的进程链在一起，组成各种队列
    1. 就绪队列
    2. 阻塞队列
+ 进程：进程实体的运行过程（是指动态性的过程），是系统进行资源分配和调度的独立单位（无线程的定义）

---

+ 组织方式：
  + 链接方式：
    + 按照进程状态将PCB分为多个队列
    + 操作系统持有指向各个队列的指针
  + 索引方式
    + 根据进程状态的不同，建立几张索引表
    + 操作系统持有指向各个索引表的指针
  
+ 进程状态：
  + 三个基本状态：
    + Running运行态：占有CPU，并在CPU上运行；
    + Ready就绪态：具备运行的条件，但没有空闲CPU，暂时不能运行
    + Block阻塞态/Waiting等待态：因等待某一事件而暂时不能运行
  + 两个非基本状态：
    + New创建态/新建态：进程正在被创建：分配资源、初始化PCB
    + Terminated终止态/结束态： 进程正在被撤销：回收资源、撤销PCB

+ 进程状态的转换：在就绪队列、CPU、不同事件的阻塞队列之间转换的过程

  ![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Operating-System/进程状态的转换.jpg)

  ![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Operating-System/进程状态和转换.png)

+ 进程控制：实现进程的创建、销毁和转换：

  > 进程状态的转换是在就绪队列、CPU、不同事件的阻塞队列之间转换的过程，这个过程需要PCB中信息的及时修改，通过原语
  >
  > > 原语的原子性是通过关中断指令和开中断指令进行的

  1. 进程的创建：
     + 创建原语：申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列中
     + 引起进程创建的事件：用户登录、作业调度、提供服务、应用请求
  2. 进程的终止：
     + 撤销原语：在PCB集合中找到进程、剥夺其CPU、终止其所有子进程、将该进程的资源返回给操作系统、删除其PCB
     + 引起进制终止的事件：正常结束、异常结束、外界干预
  3. 进程的阻塞：
     + 阻塞原语：找到要阻塞的PCB，保护线程、修改状态、插入等待队列
     + 引起进程阻塞的事件：等待系统分配、需要其他进程完成工作
  4. 进程的唤醒：
     + 唤醒原语：在阻塞队列中找到PCB，移出队列，设置就绪态，插入就绪队列
     + 引起进程唤醒的事件：等待的事件发生了
  5. 进程的切换：
     + 切换原语：保护线程（将运行信息存入PCB），将PCB移入对应阻塞队列，选择新进程，更新其PCB，根据新进程的PCB为其恢复环境
     + 引起进程切换的事件：时间片截止、遇到更到优先级的进程、主动阻塞、进程终止

  + 在这里原语发挥的作用：
    1. 更新PCB信息
       + 修改进程状态标志
       + 保存其运行环境
       + 恢复环境
    2. 将PCB插入到合适的队列
    3. 分配/回收资源

+ 进程通信：进程之间的信息交换

  > 进程不能直接访问另一个进程的空间

  1. 共享存储：分配一个共享空间，多个进程可以访问这个空间（互斥（通过操作系统工具））

     + 基于数据结构的通信：进程对共享空间的读写必须是一个规定的特定的数据结构
     + 基于存储区的通信：读写方式由进程管理

  2. 消息传递：以格式化消息（由消息头和消息体组成）为单位，通过发送消息/接手消息进程数据交换

     > 每个进程都有一个消息缓冲队列

     + 直接通信方式：将message直接接在目标进程的消息缓冲队列中
     + 间接通信方式：将message发送到中间实体（信箱（又称信息通信方式））

  3. 管道通信方式：管道：用于连接读写进程的一个共享文件pipe，本质是开辟一个大小固定的缓冲区

     + 半双工：通信双方都能用，但是同时只能一个向另一个发送，而且对管道的处理是互斥的，通信双方不能同时读写
     + 通过字节流的方式：写满则写进程阻塞，读空则读进程阻塞；没写满不能读，没读空不能写。
     + 一个数据只能被读一次

+ 线程：

  > 没有进程之前，不同程序之间只能串行运行，两个程序不能同时运行，有了进程后多个程序可能宏观上同时进行
  >
  > 每个程序内部有不同的模块，同样同时进行，于是线程出现：在每个进程下并发多个线程

  线程的出现将进程调度的单位这一特性剥夺，只保留资源的单位

  + 实现方式：

    + User-Level Thread, ULT用户级线程：不需内核层，此时对用户有多个线程，对机器进程只有一个线程
    + Kernel-Level Thread, KLT内核级别线程：用户级线程和内核级线程一一对应对应，机器知道有多个线程

  + 多线程模型：

    + 多对一：多个用户级线程对应一个内核级线程：对线程的切换，用户态层面就能换——快；但如果一个线程出错，整个内核级线程整个崩溃。

    + 一对一：用户级线程和内核级线程一一对应，并发性更好，且互不影响；但需要的资源更多，且用户态和内核态的转换频繁——慢。

    + 多对多：由一个线程库管理用户级线程和内核级线程的对应

      > 显然这个模型用户级线程的个数多余内核级线程的个数

## 调度

+ 高级调度：**调度作业**：辅存（外存）与内存之间的调度：从若干作业中选择一个为其创建进程
+ 中级调度：**调度内存**：在挂起队列中选择一个挂起进程进入内存：提供内存利用率和系统吞吐量
  > 虚拟存储技术：将暂时不运行的进程放在外存（挂起），这些进程的PCB还在内存，这些PCB放在挂起队列

  + suspend挂起态：
    + 就绪挂起：就绪态的进程被挂起，同时运行态在运行完、创建态在创建后都可能进入就绪挂起
    + 阻塞挂起：阻塞态的进程被挂起

    阻塞挂起的进程所等待的事件发生，则其进程就绪挂起

+ 低级调度：**调度进程**（进入CPU）：是最基本的一种调度：按照某个算法从就绪队列中选择一个进程为其分配处理机
  > + 进程切换：一个进程让出CPU，另一个进程占用CPU，只针对进程和处理机
  > + 进程调度：
  >   + 狭义的：从就绪队列中选择一个要运行的进程（这个进程可能是刚被暂停的，或者是另一个进程（进程切换））
  >   + 广义的：选择一个进程并进程切换

  1. 对原来运行进程各种数据的保存
  2. 对新的进程各种数据的恢复
  > 调度是有代价的

---

+ 需要进行进程调度与切换的情况：
  + 当前运行的进程主动放弃CPU：
    + 进程正常终止
    + 运行过程中发生异常而终止
    + 进程主动请求阻塞（如等待I/O）
  + 当前运行的进程被动放弃CPU：
    + 分给进程的时间片耗尽
    + 有更紧急的进程需要处理（如I/O中断）
    + 有更高优先级的进程进入就绪队列

+ 不能进行调度与切换的情况：
  1. 在处理中断的过程中：中断过程复杂，与硬件密切相关，很难做到在中断处理过程中进程
  2. 进程在操作**系统内核**程序临界区中
     > + 临界资源：一段时间内只允许一个进程使用的资源、各个进程访问互斥
     > + 临界区：访问临界资源的代码
     >
     > 这里特质内核程序的临界区，这些临界区用于访问某种内核数据结构，不可调度，但是其他临界区可能可以调度

  3. 原语：原语是原子操作，不可中断一气呵成

----

+ 进程调度的方式：
  + 非剥夺调度方式/非抢占方式：只允许进程主动放弃CPU
  + 剥夺调度方式/抢占方式：可以把运行中的进程切换下来

### 调度算法

+ 评价指标：
  + CPU时间占用率：CPU工作时间较于在线时间的比例
  + 系统吞吐量：单位时间内完成作业的数量
  + 周转时间：作业从交给系统到作业完成的时间
    > 由于并发作业的处理过程可能中断

    平均周转时间：
    + 带权周转时间：作业实际运行时间在作业周转时间的比例的倒数

    平均带权周转时间

  + 等待时间：指作业/进程处于等待处理机状态时间之和：周转时间减去实际运行时间
  + 响应时间：指用户提交请求到首次产生响应所用的时间

+ 算法的调度方式：
  + 抢占式：每进入就绪队列一个作业，就对其进程评估决策
  + 非抢占式：当前作业主动退出时再评价就绪队列中的作业选择

1. 先来先服务FCFS——队列，非抢占式
   + 优点是公平、实现简单
   + 缺点是排在长作业后的短作业带权周全时间特别大——长作业友好、短作业不友好

2. 短作业/进程优先SJ/PF, shortest Job/Process First：最短的作业/进程先进行，非抢占式  
   最短剩余时间优先算法SRTN, Shorttest Remaining time Next：抢占式

   + 追求最优的评价指标，这是优点
   + 缺点：不公平，长作业可能长期得到不满足（饥饿）——短作业友好、长作业不友好

3. 高响应优先HRRN, Highest Response Ratio Next：每次调度为**响应比**最高的作业提供服务  
   响应比的计算公式是已经等待了的时间加上要运行的时间比上要运行的时间

4. 时间片轮转RR, Round-Robin：每个进程进入队列时为其分配一个时间片，按照顺序一次执行时间片长度时间，如果进程没有执行完，则分配一个时间片并插入队列末尾，天然是抢占式，用于分时操作系统
   > 时间片由时钟中断实现

   + 时间片长度的设计：
     + 太长退化到队列算法
     + 太短将时间花费在进程切换的开销上
   + 不能区分任务的紧急程度

5. 优先级调度算法：为每个作业/进程设置优先级，调度时选择优先级更高的，既有抢占式、又有非抢占式
   > 就绪队列本身也是可以按优先级进行调整

   + 优先级可能可以改变：静态优先级、动态优先级
   + 通常设计方案：  
     系统进程优先级高于用户进程  
     前台进程优先级高于后台进程  
     操作系统更偏向于IO型进程/IO繁忙型进程（对比计算型进程/CPU繁忙型进程）（因为IO设备可以和CPU并行）

   + 缺点：如果有源源不断地高优先级进程进入，可能导致饥饿
6. 多级反馈队列调度算法：对其他所用调度算法地折中权衡
   1. 设置多级就绪队列，各个队列优先级从高到低，时间片从小到大
   2. 新进程先进入第一级队列，分配时间片并调度，仍未执行完则放入下一级队列末尾（如果在最低级则回到本级队尾）
   3. 只有更高级的队列空时才运行其次的队列进程

   + 即可抢占式、又可非抢占式
     + 非抢占的进程放在本级队列末尾
   + 对某种进程偏好：不降级
   + 会导致饥饿

## 同步和互斥

+ 进程同步/直接制约关系：为完成某个任务而创建的两个或多个进程，它们因为协调它们的工作次序而产生的制约关系
  > 这种场合要求一些进程必须先后完成，而并发性的先后顺序是随机的。

+ 进程互斥/间接制约关系：联系资源互斥共享方式和临界资源
  + 原则：
    + 空闲让进
    + 忙则等待
    + 有限等待：应该保证其在有限时间内进入（不被饥饿）
    + 让权等待：等待的进程立即释放CPU

  + 流程：
    1. 进入区：检查是否可以进入，如果进入则标记——上锁
    2. 临界区/段：访问临界资源的代码
    3. 退出去：解锁
    4. 剩余区：其他处理

----

进程互斥的软件实现：

1. 单标志法：一个进程在访问临界区后把临界区权限转交给另一个进程——每个进程进入临界区的权限只能被另一个进程赋予：通过一个标记位，不符合的进程会空循环至时间片耗尽，在退出区进行标志位切换。
   + 问题：可能出现临界区空闲且有对临界区有需求的空闲进程，但是具有权限的进程迟迟不使用，未被空闲让进原则

2. 双标志先检测：共享一个布尔数组表示各个进程是否想要访问临界区，轮到每个进程时查看其他进程是否想访问临界区，都不想进入则自己进入，在自己判断后进入前标记布尔数组
   + 问题：由于进程是异步的，可能出现一个进程判断完进入但还未标记的时候另一个进程也进入，违反忙则等待原则  
     该问题来自进程在进入临界区时干了两件事：判断、上锁。不是原子操作

3. 双标志后检测：先标记数组，然后判断，（判断是由空循环实现的），访问完临界区后取消标记
   + 先后标记数组，此时谁的判断都无法通过，死循环饥饿/死锁。

+ Peterson算法：设置标记数组表示每个进程是否想要访问，一个变量`turn`表示该轮到谁进入临界区。运行方式如下：
  ```c++
  bool flag[对应每个进程];
  int turn = 初始值;
  
  flag[自己] = true;  // 设置自己向进
  turn = 其他的进程;  // 谦让
  while (flag[别人] && turn == 那个人);
  //临界区critical section
  flag[自己] = false;
  //退出区remainder section
  ```

  + 在不争抢时是标志后检测法的理想情况
  + 在争抢时：在异步时会相互谦让，但总会谦让到一个人的头上，此时他的需求就会解决，就不会死循环饥饿/死锁

---

进程互斥的硬件实现：

1. 中断屏蔽：利用开/关中断指令实现（进入临界区必须中断，此时取消两指令），简单高校但不适用于多处理机、只使用于OS内核进程（开/关中断权限高，用户不能使用）
2. TestAndSet, TS/TestAndSetLock, TSL指令：为临界区设置一个锁，该指令会检测锁的情况并上锁，我们对该指令进行空循环，只有第一次运行时的结果才能是解锁，此时进入之后的代码，访问结束解锁，之后的进程可以重复这个过程，这个过程检查和上锁是原子操作，但是不满足让权等待
3. Swap/Exchange/XCHG指令：我们自己有个`tmp`变量，初始为真，每次会和锁的值进程交换（相当于给锁上锁），如果交换回的`tmp`是真就一直交换，所以只有第一次才是跳出循环的契机，完事后手动解锁，优缺点同上。

## 信号量机制

> Dijkstra发明

操作系统一个一对原语来操作信号量：`wait(S)`原语简称`P`和`signal(S)`原语简称`V`，`S`是信号量（简称来源Dijkstra的荷兰语）

+ 信号量类型：
  + 整型信号量：初始化为资源数量，`wait`函数中减少信号量并判断是否可以进入，仍然不满足让权等待
  + 记录型信号量：结构体维护资源数量和一个等待队列
    1. `wait`操作在处理资源数量变量后，如果发现**小于0**，将进程阻塞（符合让权等待原则）并放入等待队列
    2. `signal`操作处理资源数量变量后，如果发现**小于等于0**，则唤醒等待队列中的一个进程（变成就绪态），并为其分配资源

+ 实现进程互斥：上述机制
+ 实现进程同步：信号量初始为0，并将PV操作跳转

----

+ 管程：高级同步机制，普通的信号量机制逻辑、代码复杂，这里封装成一个类，数据成员即为临界资源，方法即为资源的读写，类内部保证不会多个进程同时使用一个方法。

### 生产者消费者

一个缓冲区，一组生产者进程想缓冲区写，一组消费者进程从缓冲区读，缓冲区没满生产者一直写，没空消费者一直读

1. 一块区域只能读或者写——互斥
2. 只有有的写才写，有的读才读——同步

![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Operating-System/生产者消费者模型.jpg)

+ 必须先同步等待再互斥等待，如果先上锁再查看是否合适，此时如果不合适它就等待了，而此时其他人也没有办法，就死锁了
+ 消费的使用过程可以放在缓冲区中，但是为了异步效率更高，放在外面

#### 多生产者多消费者

普通的生产者消费者模型是处理的同一种物品，如果有不同种处理不同的物品但是公用一个缓冲区

#### 单生产者多消费者
>吸烟者

每种吸烟者需要不同的资料，由一个供应者提供，桌子上只能放一种一个材料

+ 互斥：桌子只能放一种一个材料
+ 同步：
  + 有了材料，对应的吸烟者才能拿——分别这只同步
  + 吸烟者拿完，供应者才能继续放——所有吸烟者都对供应者同步

### 读者写者

缓冲区中的信息是一次性的，如果不是一次性的——共享文件区

+ 读进程无限制
+ 同步：
  + 同一位置的读写：
    + 写之前是空
    + 写完之前不能读
+ 互斥：
  + 两个写进程需要互斥

这里不会消费缓冲区的内容，所以不是缓冲区是共享文件

读进程之前随便

同一位置的读写应该同步

+ 写之前位置是空
+ 写完之前不能读写

两个写进程需要互斥

![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Operating-System/读者写者问题.jpg)

+ 读进程通过`rw`互斥
+ 写进程使用辅助变量`count`，只有第一个进入或最后一个退出才互斥：保证读写互斥但读和读之间不互斥
  + 这里的判断和修改不是原子操作，`mutex`保证原子操作

### 哲学家进餐

多个哲学家、多支筷子（临界资源），每个哲学家如果想用餐必须两个筷子

+ 如果对每个临界资源分别用一个信号量维护，可能出现所有人同时拿自己需要的一个，正巧没有资源了，但是每个人都等待新的资源出现，但没人空放下已经拿好的筷子，于是死锁
+ 限制同时使用筷子的进程个数，避免上面情况，不会死锁
+ 尽可能先拿重复资源，这样总有一个胜利者，失败者在没有任何资源的情况下等待不会影响他人，不会死锁
+ 先判定再对资源上锁，如果有一个不满足就一个资源也不用

## 死锁

+ 死锁：各个进程互相等待对方手上的资源，导致各进程阻塞，都无法进行
+ 饥饿：进程长期得不到资源或CPU

> 死锁肯定是相互的，饥饿的可能只有一个

+ 死循环：

> 死锁的进程在阻塞态，但是死循环时进程还在处理机上

---

+ 死锁条件：
  + 互斥条件：对互斥资源的争抢
  + 不剥夺条件：资源不会被其他进程强行夺走
  + 请求和保持条件：进程已经保持了至少一个资源
  + 循环等待条件

### 不允许死锁发生

#### 预防

1. 破坏互斥条件：把必须互斥使用的资源改成可共享的资源——SPOOLing技术，当然并不是所有资源都能如此改变

2. 破坏不剥夺条件：

   1. 如果发现不满足，就释放手上所有的资源，容易饥饿
   2. 通过操作系统进行管理剥夺

   + 缺点：
     + 复杂
     + 释放资源可能导致前一段工作的失效
     + 反复申请资源增大开销

3. 破坏请求和保持条件：采用静态分配方法，先保证所有的资源自己都能拿到，做统一一起拿，需要资源多的进程容易饥饿

4. 破坏循环等待条件：顺序资源分配法：每个进程必须按编号递增的顺序请求资源。

   + 缺点：
     + 增加新设备困难
     + 进程实际使用资源的顺序和编号不一致，浪费

![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Operating-System/预防死锁.jpg)

#### 避免

+ 安全序列：在当前情况下，如果系统分配的资源，仍然有办法让每个进程的需求顺利完成
  + 如果有安全序列，系统就是安全状态，否则就是不安全状态

+ 银行家算法：

  > Dijkstra为银行系统设计

  1. 按照进程数量和资源数量组成矩阵
     + 所有进程对各个资源的最大需求矩阵Max
     + 所有进程对各个资源的当前已经分配的矩阵Allocation
     + 上面两个矩阵对应位置相减就是需求Need矩阵
     + 一个向量Available表示当前系统还有的资源
  2. 一个向量Request表示当前进程想要的资源
     1. 判定：看此次申请是否和你最开始说好的一致：比较Request<Need
     2. 查看能否允许：比较Requet<Available，不足则等待
     3. 试探性分配：available-=request, allocation-=request, need-=request
     4. 执行安全性算法，成则分配，否则还原等待

  + 安全性算法：重复遍历所有进程（行），如果存在当前资源可以运行的进程，假设其运行完毕、归还资源、纳入安全序列。如此往复看最后是否安全序列包含所有进程

### 允许死锁发生
+ 死锁的检测：

  1. ![](https://cdn.jsdelivr.net/gh/zweix123/CS-notes@master/resource/Operating-System/资源分配图.jpg)

  2. 模拟安全性算法，如果能消除所有边，即可完全简化的，一定没有发生死锁，否则就是发生死锁

+ 死锁的解除：

  1. 资源剥夺法
  2. 撤销/终止进程法
  3. 进程回退法

  + ”处罚“哪个？
    1. 进程优先级
    2. 已经执行多长时间
    3. 还要多久完成
    4. 进程已经使用了多少资源
       1. 进程是交互的还是批处理的