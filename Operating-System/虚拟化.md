操作系统希望管理在机器上运行的程序（包括控制和保护），那么就不能让程序直接运行在机器上，怎么才能让操作系统获得对程序运行状态的控制权呢？

这需要硬件的支持，比如内核态和用户态。

机器运行**时间中断**，定期停止程序，机器也由用户态变成内核态，此时由操作系统执行。  
不仅时间中断会造成这样的结果，用户程序调用系统调用也会发生上面的情况。

那么当系统调用时，机器是怎么知道一个系统调用应该对应的jump到哪里的代码呢？所以操作系统要在boost time时定义一个trap table

## CPU虚拟化

上面表述的也是CPU虚拟化的一部分。

### 调度

## 内存虚拟化

在程序的视角，内存都是从0开始的，但是它可能在物理内存的任何位置  

这需要硬件的支持用两个寄存器表示程序实际所在的物理内存范围，在访问时进行地址转换（也是硬件进行）

### Seg

在普通的内存模型中，我们发现地址从低到高是堆，从高到低是栈，有大量的内存被浪费了。

于是把程序需要的内存划分成多个段，比如代码段、栈段、堆段，这些在进程看来仍然是一块的，但是操作系统可以把它们任意放置，这需要为每一段都设置一对寄存器

让我们进一步实现内存共享，就是给每个段设置一个表示嘛，比如只能读、只能执行之类的。

### 内存碎片

上面也说，物理内存被分成很多的段，那么就会有内存碎片，怎么解决呢？

### 页