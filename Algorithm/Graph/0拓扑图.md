# 拓扑排序

拓扑图：将图按拓扑排序的顺序放置，只有由前指向后的边

```c++
//n, du[N], qu[N];  // 点的个数, 每个点的入读和数组模拟队列
void topsort() {
    int hh = 0, tt = -1;
    for (int i = 1; i <= n; ++ i) if (! du[i]) qu[++ tt] = i;
    while (hh <= tt) {
        int node = qu[hh ++];
        for (int son, e = head[node]; e; e = lext[e]) {
            son = to[e];
            if (-- du[son] == 0) qu[++ tt] = son;
        }
    }
    //此时的qu[]中，[0, tt - 1]即为拓扑排序结果
    //if (tt == n - 1) 没有环
}
```

+ 拓扑图`=`有向无环图DAG：
  + 判断有向图是否有环：记录出队点的数量，看其是否等于图中点的数量
+ 要求拓扑序字典序最小：拓扑排序是一个广搜的过程，在每个点扩展出的点入队前先进行排序（初始化和更新时都要）
+ 有向无环图的最长路：普通的最长路是NP问题，但是有向无环图的最短路可以按照拓扑排序的顺序进行更新
  + 边权全为正的差分约束：
    + 有向无环图：拓扑排序最长路
    + 有环：无解
