# 概论

+ 闫氏DP分析法：

  ```mermaid
  graph LR;
  	动态规划 ---> 状态表示:数组
  	状态表示:数组 ---> 集合:数组表示什么
  	状态表示:数组 ---> 属性:数组的值是什么
  	动态规划 ---> 状态计算
  	状态计算 ---> 集合的划分:一个椭圆划线,每个部分也是集合
  	不重不漏
  ```

  

+ 循环数组：循环变量为`i`，则本行索引为`i & 1`，上一维索引为`i - 1 & 1`：直接当不滚动的写，然后在第一位**与上1**。

## 数字三角形：从搜索到记忆化再到动态规划

1. 有数字矩阵，从`(1, 1)`到`(n, m)`，每次只能向右或向下走，求所有可行路径的“路径所经数字”之和的最大值

   ```c++
   int n, m, g[N][M];  // 如上
   int f[N][M];
   int work() {
   	for (int i = 1; i <= n; ++ i)
   	    for (int j = 1; j <= m; ++ j) {
   			f[i][j] = g[i][j];  // 如果题目变成取最小, 则此处应该取极大, 然后取更小值
           	if (i != 1) f[i][j] = max(f[i][j], f[i - 1][j] + g[i][j]);
           	if (j != 1) f[i][j] = max(f[i][j], f[i][j - 1] + g[i][j]);
       	}
   	return f[n][m];
   }
   ```

2. 扩展：对于上述路径，每个点的值只能对一个路径有贡献，求这种情况下和的最大值和次大值

   运用一定区间DP的思想，两个路径按步数共同前进

   `f[步数k][第一个路径的x（x1）][第二个路径的x（x2）]表示路径之和`，则两个路径的端点的`y`分别是`y1 = k - x1, y2 = k - x2`

   ```c++
   int n, m, g[N][M], f[N + M][N][N];
   int work() {
       for (int k = 2; k <= n + m; ++ k)
           for (int i1 = 1; i1 <= n; ++ i1) 
               for (int i2 = 1; i2 <= n; ++ i2) {
                   int j1 = k - i1, j2 = k - i2;
                   if (j1 < 1 || j1 > m || j2 < 1 || j2 > m) continue;
                   int t = g[i1][j1];
                   if (i1 != i2) t += g[i2][j2];  // 不能重复取一个位置
                   int &x = f[k][i1][i2];  // tips
                   // 分别考虑两个路径的来向, 每个来向的y坐标被隐含
                   x = max(x, f[k - 1][i1 - 1][i2] + t);
                   x = max(x, f[k - 1][i1][i2 - 1] + t);
                   x = max(x, f[k - 1][i1][i2] + t);
                   x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);
               }
       return f[n + m][n][n];
   }
   ```
   
