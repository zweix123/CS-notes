# 进程通信

## 管道

```c
#include <unistd.h>
int pipe(int fd[2]);
//-->成功返回0, 失败返回-1
//-->参数fd[]维护两个文件描述符, fd[0]指向管道的读端, fd[1]指向管道的写端.
```

+ 交互：**管道是半双工的**

  + 从写端写：

    ```c
    write(fd[1], char*, int);
    ```

  + 从读端读：

    ```c
    write(fd[0], char*, int);
    ```

+ 应用：父子进程的交互：管道的创建在子进程的创建语句之前。

  + 管道是半双工的，某一个进程通常将不用的端关闭：`close(fd[])`

## 共享内存

> 我们发现pipe只能父子进程之间通信，这绝对是不够的。

+ 共享存储器shared memory：不同进程通过共享彼此的虚拟空间来达到互相对共享区操作和数据通信的目的
+ 消息message：用于进程之间传递分类的格式化数据
+ 信号量semaphore机制：用于通信进程之间向前推进时的同步控制，一般和共享存储器一起使用

---

命令行管理：

```shell
ipcs   # 用于查看系统中共享存储区, 消息队列和信号量的情况

ipcrm  # 用于删除系统中存在的共享存储区, 消息队列
ipcrm -M key  # 表示根据关键字删除共享存储区
ipcrm -m id   # 表示根据标识符删除共享存储区
ipcrm -Q key  # 表示根据关键字删除消息队列
ipcrm -q id   # 表示根据标识符删除消息队列
```

---

相关系统调用`<sys/shm.h>`：

+ 创建共享内存：

  ```c
  int shmget(key_t key, size_t size, int shmflag);
  //-->调用成功返回共享内存标识符, 否则-1
  ```

  + `key`：共享内存关键字

    > `key_t`是一个长整型

  + `size`：该共享内存的字节大小

  + `shmflag`：

    + 低9位：属主、属组、和其他用户的访问权限

    + 其他位：创建方式：

      | 参数        | 描述                                                         |
      | ----------- | ------------------------------------------------------------ |
      | `IPC_CREAT` | 创建共享内存，如果共享内存已经存在，就获取该共享内存的标识号。 |
      | `IPC_EXCL`  | 与宏IPC_CREAT一起使用，单独使用无意义，此时只能创建一个不存在的共享内存，如果内存已存在，则调用失败。 |

+ 映射共享：需要将共享内存段映射到进程地址空间后才可以访问

  ```c
  void* chmat(int shmid, const void* shmaddr, int shmflag);
  //--> 成功返回共享内存映射空间的起始地址, 否则-1并置errno错误信息
  ```

  映射到哪里由后两个参数确定：

  1. `NULL, ...`：系统自动
  2. `非NULL, 未置SHM_RND标志位`：shmaddr
  3. `非NULL, 置SHM_RND标志位`：`shmaddr - (shmaddt % SHMLBA)`

+ 释放共享映射：

  ```c
  int shmdt(const void* shmaddr);
  // return 0 or 1
  ```

  + 该函数并不是删除共享内存，共享内存会想智能指针一样

+ `shmctl`