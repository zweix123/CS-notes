# 绪论

+ C的特点：

  1. 设计特性：自顶向下的规划、结构化编程和模块化设计。

  2. 高效性：与汇编相当的微调控制能力。

  3. 可移植性强大而灵活（——想要拥有自由就必须时刻警惕）。

+ 调试(debug)：语法错误（编译器的报错和警告）、语义错误（跟踪*程序状态*+输出中间变量+*调试器*）。

+ 空白：空格、制表符或换行符。

## C的标准

| 年份 | 名称                       | 语言特性      | 说明                                                         |
| ---- | -------------------------- | ------------- | ------------------------------------------------------------ |
| 1978 | K&R标准         (经典C)    |               | 没有C库，来自两位C语言之父合著的《The C Programming Language》 |
| 1990 | IOS/ANSI标准(*C89*或*C90*) | 定义语言和C库 |                                                              |
| 1999 | IOS/IEC标准   (*C99*)      |               | 国际化、弥补缺陷和提高计算的实用性                           |
| 2011 | (*C11*)                    |               |                                                              |

## C的运行

1. *源代码*文件（文本文件），拓展名是`.c`

   >  区分：文本文件：		只有文字本身
   >
   >  ​		   字处理器文件： 还有字体和格式等

2. 翻译：

   1. 源代码出现的字符映射到源字符集，处理多字节字符和*三字符序列*（字符扩展）

   2. 定位每个反斜杠后面跟着换行符的实例并删除$\Rightarrow$将*物理行*确定为*逻辑行*

   3. 把文本划分成预处理记号序列、空白序列和注释序列（*记号*是由空格、制表符和换行符分隔的项）

      编译器将注释替换为空格。

3. 预处理：预处理器查找每一行以#号开始的预处理指令

4. *编译*：编译器将源代码转换成*目标代码文件*；

   > 目标代码：缺少*启动代码*、没有链接*库函数*；拓展名为`.obj`
   >
   > > 启动代码：程序与操作系统的接口，不同操作系统不一样
   > >
   > > 库函数：

   > 编译器：
   >
   > + UNIX C编译器（cc）：`.c`文件 -> `.o`文件 -> `.out`文件(  `.exe`文件)
   > + GNU编译器集合（gcc编译器等）：`gcc [options] [filenames]`
   > + LLVM项目（clang编译器等）

   >  不同系统上编译：
   >
   > + Linux：gcc
   >
   > + PC：别处获取C编译器
   >
   > + IDE（集成开发环境）
   >
   >   > 错误与警告
   >
   > + Windows/Linux双系统
   >
   > + Macintosh（Mac）

5. *链接*：将启动代码、目标代码、库函数（只取需要的部分）合并成一个*可执行文件*

   > 可执行文件：拓展名是`.exe`

   部分系统是编译器调用链接器，有的则是需要单独启动。

6. 运行

+ 多文件的运行：

  + 多文件运行时所有文件属于同一组文件，其中每个文件称为*翻译单元*，在此称每个翻译单元为文件。

  + 程序设计：

    1. 头文件（.h文件）：各种声明，做好防护

    2. 定义文件（.c文件）：头文件中声明的定义，include头文件，内部头文件的引用和名称空间的using不影响使用文件

       > 因为使用文件include的是.h文件，编译器只是在此寻找定义，而不是文本替换

    3. 使用文件（.c文件）：含主函数，include头文件。链接时链接定义文件。
    
       > include头文件时不同文件的不同包含方式：
       >
       > + 尖括号`<>`包含系统头文件    ：编译器优先去。
       > + 双引号`""`包含自定义头文件：编译器优先去，然后去。

+ win命令行编译运行C程序：

# 数据

zweix：任何数据都需要硬件来存储，称每个抽象数据存储的具体位置为**地址**，C语言会对数据根据数据类型分配空间大小以及确定**值**的解释方式。这是数据的属性的联系。

+ **`typedef`**机制：为现有类型创建**别名**，是一种高级数据特性。
  
  + 语法：**`typedef`**` 类型 新类型名;` 之后可使用新类型名作为类型名；本质是根据已有类型”定义“新类型。
  
  > typedef机制由编译器解释，而不是预处理器做文本替换。
  >
  > 与`#define`相比，类型定义和文本替换不一样：
  >
  > 比如指针且一系列变量时，自定义是改变类型，文本替换只影响第一个。
  >
  > ```cpp
  > #define int_ int *
  > int_ a, b, c;  //相当于int * a, b, c;这是只有a是指针，b和c是普通变量
  > typedef int* int_;
  > int_ a, b, c;  //int_就是声明指向int的指针，所以a，b，c都是指针
  > ```
  
  + 函数指针：`typedef 函数返回类型 (* 新类型)(参数列表);`

## 数据对象

数据对象（存储类型）：变量（程序可操作的存储区的名称）和常量（字面量）（程序执行期间不会改变的固定的值）

> 符号常量：由#define定义的宏。
>
> 常量：由const限定的变量。
>
> 字面量：即时处理的数值、字符、字符串。

+ 初始化

+ 数值字面量进制的表示：

  | 进制     | 表示方法       |
  | -------- | -------------- |
  | 十进制   | 无             |
  | 二进制   | 无             |
  | 八进制   | 前缀`0`        |
  | 十六进制 | 前缀`0x`或`0X` |

+ 数值字面量数据类型的强调：

  | 数据类型  | 表示方法                                |
  | --------- | --------------------------------------- |
  | long      | 后缀l或L                                |
  | long long | 后缀ll或LL                              |
  | unsigned  | 后缀u（可与其他组合，无顺序，uLL、LLu） |
  | float     | 后缀f或F                                |
  | double    | 后缀l或L                                |

+ 以上两点可一起使用。

+ 常量名称建议大写

## 基本类型

+ 溢出（上溢和下溢）：

  + 上溢：与实现的存储方式和数据的数据类型有关，变量指向一块地址，数据类型规定这块地址的大小和解释方式，在溢出过程中溢出的数据可能会对相邻的内存产生的影响，而其本身的值会按其数据类型做解释。
  + 下溢：当精度不足是，C语言采取的是*截断*保留，而不是四舍五入。

+ 类型转换

  1. 升级：

     + 无论是unsigned还是signed的char和short自动转换成int（有必要还会转换成unsigned int）。

     + flost自动转换成double

  2. 降级 -> 截断

  3. 强制类型转换：

     格式：`(typeName) value` 或者 `typeName (value)`

  赋值表达式语句中，右值的**计算结果**（隐式地）转换成左值变量的类型。
  
  > 如果没有显式地强制转换，隐式地升级转换，且右值表达式的结果出现溢出，即使其符合左值，仍会被降级，然后再进行赋值
  >
  > > 机器解释：计算机在一块内存进行计算，其状态按照这块内存的数据类型进行解释，计算后将其拷贝到左值。
  
+ 符号

  | 关键字         | 特性       | 说明                           |
  | -------------- | ---------- | ------------------------------ |
  | **`unsigned`** | 无符号     | 附属关键字（修饰基本整数类型） |
  | **`singed`**   | 强调有符号 | 强调有符号                     |


### 整数类型

数据类型在不同机器上存储大小会有变化——为了速度更快

+ 有附属关键字修饰的情况下基本整数类型int可省略。

+ 附属关键字组合使用：short和long不可一起用；符号附属关键字可以和其他关键字组合使用，前后顺序不影响；

| 关键字          | 特性                 | 说明                           |
| --------------- | -------------------- | ------------------------------ |
| **`int`**       | 有符号               | 基本整数类型                   |
| **`short`**     | 不多于int，有符号    | 附属关键字（修饰基本整数类型） |
| **`long`**      | 不少于int，有符号    | 附属关键字（修饰基本整数类型） |
| **`unsigned`**  |                      | 附属关键字（修饰基本整数类型） |
| **`singed`**    | 强调有符号           | 附属关键字                     |
| **`long long`** | 不少于long，至少64位 | 附属关键字，C99标准添加        |

> 并不是short和long的大小是根据int确定的，实际上是int的大小被前两者限制。

| 类型           | 存储大小    |      | 值范围                                               |
| :------------- | :---------- | ---- | :--------------------------------------------------- |
| char           | 1 字节      |      | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节      |      | 0 到 255                                             |
| signed char    | 1 字节      |      | -128 到 127                                          |
| int            | 2 或 4 字节 |      | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 |      | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      |      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      |      | 0 到 65,535                                          |
| long           | 4 字节      |      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      |      | 0 到 4,294,967,295                                   |

+ 溢出（上溢和下溢）

  原理是存储长度固定，读取方式不同 -> 值在范围内循环

#### 字符型

+ **关键字**：**`char`**

+ 本质：整数，使用数字编码处理字符

+ 大小：8位存储单元，并把1字节定义为char类型占用的位数

+ 编码方式：

  + 标准ASCLL码：0~127
  + 拓展ASCLL码：
  + IOS/IEC 10646标准：包括多余255的字符集，比如日本汉字字符集、商用同一码。

+ *字符常量*：用单括号括起来的单个字符。

+ 非打印字符：代表行为的字符

  1. 使用ASCLL码

  2. 转义序列：用于代表难以表示或无法输出的字符，都以反斜杠（\\）开始。  //==zweix_转义序列==

     | 转义序列                   | 含义                        |
     | -------------------------- | --------------------------- |
     | 控制*活跃位置*（光标）     |                             |
     | `\a`                       | 警报（ASCLL C）（蜂鸣器）   |
     | `\b`                       | 退格——Backspace键（退格键） |
     | `\n`                       | 换行——Enter键（换行符）     |
     | `\f`                       | 换页                        |
     | `\t`                       | 水平制表符——Tab键           |
     | `\v`                       | 垂直制表符                  |
     | 打印用于定义字符常量的字符 |                             |
     | `\\`                       | 反斜杠（\\）                |
     | `\'`                       | 单引号                      |
     | `\"`                       | 双引号                      |
     | `\？`                      | 问号                        |
     | 用不同进制表示ASCLL码      |                             |
     | \0oo                       | 八进制数（要求oo有效）      |
     | \xhh                       | 十六进制数（要求hh有效）    |
  
+ *字符串*：双引号括起来。

#### 其他类型

+ _Bool类型（C99）（布尔类型）（头文件`stdbool.h`），于表示布尔值

  > C语言具有真值假值，比如在if语句或者循环语句，表达式被强制转换为布尔类型的值然后判定真假（0为假，非0为真）
  >
  > C99提供直接使用布尔的类型_Bool。
  >
  > C99之前可以使用枚举`enum bool{false, true}; `

+ 可移植类型：`stdint.h` 和 `inttypes.h`

  + 精确宽度整数类型 ：`int32_t`（32位有符号整数类型）

  + 最小宽度类型：`int_least8_t`（可容纳8位有符号整数值的类型中宽度最小的类型）

  + 最快最小宽度类型 ege：`int_fast8_t`（系统8位有符号值最快的整数类型的别名）

  + 最大整数类型：有符号`intmax_t`（可以储存任何有效的有符号整数位）、无符号`uintmax_t`。

    ​							转换说明是 `%j` 和整型转换说明一起使用。

---

### 浮点数类型

+ 计数法

  | 一般计数法 | 科学计数法       | 指数计数法                 |
  | ---------- | ---------------- | -------------------------- |
  | $123.123$  | $1.12123 * 10^2$ | $1.12123e2$或者$1.12123E2$ |

浮点数计算时认为其为double型，计算后截断为对应数据类型 -> 会影响速度 -> 强制转换或类型强调消除影响。

+ 浮点数存储的解释方式是指数计数法

| 说明         | float                                    | double                       | long double（C99新增） |
| ------------ | ---------------------------------------- | ---------------------------- | ---------------------- |
| 有效数字     | 6位                                      | 13位                         | 至少与double同         |
| 取值范围     | 1e-37 ~ 1e37                             | 同float                      |                        |
| 存储大小     | 32位(1符号+8指数+23非指数(尾数、有效数)) | 64位(1符号+11指数+52有效数） |                        |
| 常量类型强调 | 后缀f或F                                 | 后缀l或L                     |                        |

+ 溢出

  + 上溢：未被定义：赋予*无穷大*的特定值——显示`inf`

  + 下溢：丢失精度，无法恢复

    ​			损失全精度：*低于正常值*的

  + 不存在：`nan`或`NaN`——多出现于三角函数

  + 舍入错误：浮点型有有效长度，如果值很长则可能损失很多数据

---

### 其他类型

+ 复数类型：

  C99支持，C11把复数软件包作为可选项

  每个变量包含两个对应的值，分别表示复数的实部和虚部

  + float _Complex
  + double _Comples
  + long double_Comples

+ 虚数类型：

  + float _Imaginary
  + double _Imaginary
  + long double _Imaginary

+ 如果包含complex.h头文件，可用complex代替\_Complex，可用imaginary代替\_Imaginary、用I代替-1的平方根

  \_Complex和\_Imaginary都是关键字

  因为相关标准出台较晚，如果直接定义关键字，之前的程序就可能失效了，所以放在头文件中的宏。

## 复合类型

### 数组和指针

***数组***

+ 定义：同类型数据元素的有序序列：`type arr[len];`
  + 整个数组有一个数组名

  + 方括号里使用整型常量表达式（值大于0）

    > C99允许方括号里是变量，即*变长数组* 简称VLA，C11放弃，不是语言必备的特性。

  + 通过成员运算符（`[]`）和整数下标访问数组中单独的项或**元素**

    > 用于识别数组元素的数字被称为*下标*、*索引*或*偏移量*，必须从0开始计数。数组元素存储在内存相邻位置

  + 储存单个值得变量有时被称为*标量变量*，对比数组的。

+ 初始化：

  1. *列表初始化*：以逗号分隔的值列表（用花括号括起来）来初始化数组：

     `type arr[len] = {value0, value1, ..., valuelen_1};`

     如果值的数目和数组长度不一致，则从头开始初始化，**其余初始化为0**。如果多余则会编译错误。

     也可以忽略方括号的数字，编译器根据初始化列表的项数自动确定大小。`项数 = sizeof arrays / arrays[0];`

  2. *指定初始化器*：`int arrays[] = { [下标] = 值, ……};` 。

     + 指定初始化器之后的值，按顺序填充初始化器元素后面的位置。

     + 如果再次初始化，可以覆盖。

+ + 由于“相信程序员原则”，编译器不检查“下标越界”问题；为了更快。

---

多维数组

+ 定义：主数组的元素是数组。									数组定义的套娃
+ 初始化：初始化主数组的元素，每个元素是数组。 数组初始化的套娃     也可取消内部大括号，但要保证数值个数正确。
+ 其他多维数组

----

变长数组（VLA）：即允许变量作为数组维数做定义（变指的是定义时的不定，定义后大小就确定不能变了）

+ 函数原型：`int sum(int r, int c, int arr[r][c]) {}`是允许的；数组实参传递的仍然是指针，可修改。

  > 因为`r`和`c`已经在声明形参数组前被函数得知。

---

数组名是数组首元素的地址`arrays = &arrays[0];`

+ 地址*按字节编址*，指针+1增加的是一个存储单元，对数组来说，+1后的地址是下一个元素的地址。

  `dates + 2 == &dates[2]`  `*(dates + 2) == dates[2]`

  指针表示法和数组表示法编译器生成的代码一样，两种方法等效。

+ 函数中调用数组：参数名是数组首地址。

  `int sum(int * a) {}` 

  `int sum(int a[]) {}` 只能用于形式参数；提示不仅是指针，还是数组。

  以上两种不能获得数组大小：要么传递辅助变量，要么传递数组末尾地址。

  另外，如果为了避免错误修改原数组：`int sum(const int a[]) {}` ，这里const关键字告诉编译器。

  ​			即函数将数组视为常量、不可更改。

+ 指针和多维数组

  + 本质：*双重间接*：地址的地址或指针的指针。

    对于ege：`int arr[x][y];`	//x, y表示具体的大于0的整数，这里为了广义的解释

    + `arr`是该数组首元素地址，但首元素是内含$y$个`int`元素的数组，所以`arr`是内含$y$个值的数组的地址。
  
    + `arr == &arr[0], arr[0] == &arr[0][0]` 但`arr`是$x$个`int`数组的首地址，`arr[0]`是$y$个`int`变量的首地址。
  
    + `arr + 1 == arr[1],  arr[0] + 1 == arr[0][1]`
  
      对前者来说，$1$相当于$y$个`int`的地址和，都后者来说，$1$相当于$1$个`int`的地址和。
  
    + `*(arr[0]) == arr[0][0], *arr == arr[0], **arr == arr[0][0]` 解引用一次还是地址。
  
  + 定义指向多维数组的指针
  
    对于上边的例子，应为` int (* pd)[y]; pd = arr;` 这里，`pd`是指向$y$个`int`值的指针（指向一块大地址的指针）
  
    `[]`的优先级大于`*`，所以必须要有括号，不然相当于指针数组：
    
    > 二维数组是`type (* name)[SIZE]`，这个地址连续，可从头递推。
    >
    > 指针数组是`type * name[SIZE]`，这个每个元素指向的地址可以无关。
    
    不可以`int ** pd; pd = arr` ：`pd`是指向指针的指针，两者不一样。


+ 多维数组和函数：

  + 传递参数时除第一维之外的大小必须确定：`int (* pd)[y]` or `int pd[][y]` ，同样，第一维可以写，不过会被忽略，行数只能另外传递。

    > 本质还是传递一种指针，一种指向一块地址的指针，所以要告知除了第一维之外的大小。

----

***指针***

+ 定义：一个值为内存地址的变量（或数据对象）

+ 操作：

  + 赋值：可以把地址赋给指针，注意地址应该和指针类型兼容（兼容性：==指针没有数据类型的强制转换==）

  + 解引用：`*`运算符给出指针指向地址上存储的值

    + 普通变量把值作为基本量，把地址作为通过&运算符获得的派生量

      指针变量把地址作为基本量，把值作为通过*运算符获得的派生量

  + 取址：和所有变量一样，指针变量也有自己的地址和值

  + 指针与整数相加：可以使用+运算符把指针与整数相加或整数与指针相加——指针按所知类型的字节大小为单位递增。

  + 递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。

  + 指针减去一个整数：指针必须是第1个运算对象，整数是第2个运算对象。

  + 递减指针：递增指向数组元素的指针可以让该指针移动至数组的上一个元素。

  + 指针求差：可以计算两个指针的差值

    ​					两个指针指向同一个数组的不同元素，求出两元素之间的距离。**差值单位与数组类型的单位相同**。

  + 比较：比较两个指针的值，前提两个指针所指向相同的类型的对象。

  递增递减的问题：编译器不会检查指针是否仍指向数组元素，C只能保证数组内和数组后第一个指针有效，超过这个范围是未定义的

+ 初始化：创建一个指针时，系统只分配了存储指针本身的内存，并未分配存储的数据。

+ **函数指针**：让函数中的同一语句使用不同的函数。

  + 结合typedef机制可以使用函数指针数组。

---

#### 字符串

+ 定义：

  1. 字符串常量（字面量）：双引号括起来的一个或多个字符的序列

     > 本质：双引号中一个或多个字符和编译器自动加入末尾的\0字符

     > 注意：双引号不是字符串的内容
     >
     > > 使用字符串加反斜杠

     **存储类别**：静态存储类别——其本身被视为指向该字符串存储位置的指针。

  2. char类型数组：以空字符（\0）结尾的char类型数组。

     初始化：

     + 保证空间足够。
     + 可字符串常量赋值
     + 常规数组初始化：末尾手动添加空字符（\\0）否则是字符数组，不是字符串。

  3. 指向char的指针

  > 形式**比较**：
  >
  > + 数组形式（`arr[]`）：把静态存储区的字符串拷贝到数组中。
  >
  >   在程序运行时分配内存，所以字符串有两个副本，一个是静态内存的字符串字面量，另一个是arr数组。
  >
  >   之后，编译器把arr识别为该数组都元素地址（`&arr[0]`）的**别名**，即其是**地址常量**，不可改变。
  >
  >   ​																																				 但数组元素可以修改。
  >
  > + 指针形式（`* pt`）：把字符串的地址拷贝给指针。
  >
  >   在程序运行时分配内存，指针本身有其存储位置，这个位置存储的值静态的字符串地址，存储的值可以改变。
  >
  >   ​																																					  但其指向的字符串不可改变。
  >
  >   至少是C标准没有定义过的。所以建议`const char * str = "";`的写法。
  >
  > 比较**结果**：
  >
  > 数组形式全盘拷贝，速度慢，但可修改。
  >
  > 指针形式只拷贝地址，速度快，但修改未被C定义
  
+ 存储：C语言没有专门存储字符串的变量类型，所以存储在char型的数组中。

  + 数组末尾的字符'\0'（*空字符*），ASCALL码为0，C的字符串必须以空字符结尾。标准输入输出和字符串常量的末尾空字符编译器自动填充。

+ 相关函数

  `char sam[N];`

  + `scanf("%s", sam);` 与其他类型不同，参数前没有”&“， 因为sam本身是指向字符串首的指针。

  + `printf("%s", sam);`

  + `strlen(sam);` 返回变量存储的字符串的长度

    + 与sizeof的区别

      | 说明         | strlen()                           | sizeof                 |
      | ------------ | ---------------------------------- | ---------------------- |
      | 字符数组     | 存储字符串的长度，不包括末尾空字符 | 字符数组的存储空间长度 |
      | 字符串字面量 | 字符串长度，不包括末尾空字符       | 包括末尾空字符         |
  
  上面相关函数的参数是地址，对应着可以`str + 1`的方式从下标1开始存储，strlen也要改，它的内部实现是遇空字符停。


---

### 结构联合枚举

+ 运算符：

  + 成员运算符（`.`）：指定模板的成员，可连续使用

  + 间接成员运算符（`->`）：结合指针访问模板的成员

    ​										    也可用解引用和成员运算符一起来访问，要有括号

***结构***：

有时把结构称为模板（与C++含义不同），个人理解是创建一个新的数据类型，并规定独特的规则。

块内为成员列表或字段列表，这是结构的布局、格式或样式。

1. 声明：关键字`struct`

   1. 结构布局声明：

      ```cpp
      struct 标记 {
          成员（字段）列表
      };
      ```

      本质上来说，这样创建了一个`struct 标记`的新类型。

   2. 结构变量声明：

      声明了一个”标记“结构布局的结构变量 

      ```cpp
      struct 标记 name;  //struct关键字是必需的。
      ```

      使用方法类似基本类型

   + 变量的定义可直接跟在布局声明的第二个大括号和分号之间，这种情况可省略标记，

     如果想重复使用，必须要有标记，或者使用`typedef`。

2. 初始化：

   1. 大括号初始化，类似数组初始化规则。

   2. 初始化器：点运算符和成员名标识特定的元素。

      ​					可按任意顺序

      ​					其余为普通初始化

      ​					可覆盖

   允许结构赋值

3. 复合字面量：`struct 标记 { 初始化列表 };` 

   + 可用来初始化结构
   + 可以用函数传递参数

4. 访问：

   1. 结构成员运算符（点运算符）（.）：后接成员（”点加成员“类似数组的下标）								  `结构变量.成员变量`

   2. 用指针访问成员

      1. 使用间接成员运算符（`->`运算符）（一个连接号（-）后跟一个大于号（>）组成）后接成员  `结构指针 -> 成员变量`
      2. 解引用运算符                                                                                                                                      `(*结构指针).成员变量 `

5. 指向结构的指针

7. 向函数传递结构的信息

   1. 传递结构成员
   2. 传递结构的地址
   3. 传递结构

   可以传递结构数组

8. 伸缩型数组成员（C99）

   在结构中定义“不知大小”的数组，即[]没有具体大小，在结构定义是有利用`malloc()`针对其他成员和这个数组分配空间

   规则：

   1. 伸缩型数组成员必须是结构中最后一个成员

   在`malloc()`分配时认为可伸缩数组不存在

   ege：

   ```cpp
   struct sam{
   	int num;
       int a[];
   }
   struct sam * pt;
   pt = malloc(sizeof(struct sam) + n * sizeof(int));
   ```

   这样的结构不能进行拷贝，不能赋值。

9. 其他

   1. 结构数组，它的[]运算符针对结构，而不是成员。

   2. 结构可嵌套

      使用时重复应用点运算符，从左往右解释

   3. 匿名结构（C11），在使用时直接将其认为为块内变量。

   4. 结构存储字符数组和字符指针不一样

      + 字符数组：开辟对应空间。
      + 字符指针：若初始化，则指向其他位置的字符串；未初始化是地址未知，有风险，可利用`malloc()`函数

10. 数据库中的结构：

    + *记录*：存储在一个结构中的整套信息

      *字段*：单独的项
      
    + 由于数据库中一个结构可能具有很多的成员，在I/O的时候不方便，C提供一个以结构为单位的I/O函数

      + `fwrite(&结构名, sizeof(struct 标记), 数量, pbook);`
      + `fread()`

      要求文件为二进制文件。

---

***联合***：联合变量最终类型是成员类型之一；存储：按照成员中最大字节的类型分配；其存储的值（和对应的类型）可修改。

1. 定义：关键字`union`

   + 模板定义：
   + 变量定义：

   类似结构。

2. 初始化：
   1. 联合赋值
   2. 直接赋值
   3. 指定初始化器赋值
   
3. 用法：

4. 匿名联合（C11）

***枚举类型***：声明符号名称来表示整型变量。使用`enum`关键字，可以创造一个新“类型”并指定它可具有的值。

​					目的是提高程序的可读性和可维护性。

+ 理解：本质仍是无符号的递增整型，不过其可以使用对应的符号。

+ 定义：说出符号名称，按顺序代表数值（C可以使用++，C++不允许）。

+ 赋值：可以为枚举常量指定整数值

  ​      	  如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被赋予后续的值

+ 用法：

---

### 其他类型

+ 复合字面量：代表数组和结构的字面量；

  数组：`(type []) { ………… }` ，方括号里可以有，没有编译器可以自动计算。 高维一样。

  ​			复合字面量是匿名的，不能提前创建再使用， 必须同时进行，

  ​			但利用指针记录地址也是一个用法 `int * pd; pd = (int [2]) { 123, 456};`

---

## 存储类别

+ 名称空间：表示程序中的各部分

  作用域：名称空间概念的一部分

  同作用域下的变量名同名会冲突，不同作用域则不会；

  特定作用域的结构联合枚举与变量常量的名称空间不同，相互间（前者们和后者们）可同名。

+ *对象*：被存储的每个值占有的一定物理内存

  + 说明：对象可以存储一个或多个值，一个对象可能并未存储实际的值，但它在存储适当的值时一定具有相应的大小。

  + **存储期**：指对象在内存中保留时间。

    + 静态存储期：在程序执行期间一直存在，ege：文件作用域（全局变量）

    + 线程存储期：用于并发程序设计（程序被分为多个线程），从被声明时到线程结束一直存在

      ​						关键字`_Thread_local` 声明一个对象，每个线程都获得该变量的私有备份

    + 自动存储期：在块执行期间存在，ege：块作用域（局部变量）

      ​						在块作用域声明静态存储期的变量——关键字`static` 。

    + 动态分配存储期：

+ *标识符*：一个可以指定特定对象的内容

  + 说明：指定对象的方式不仅是使用标识符，还有表达式（ege：` * sam = 10;`）。

  + 左值               ：指定对象的表达式

    可修改的左值：可以修改对象的左值

  + **作用域**：程序可访问标识符的区域

    + 块作用域：局部变量（块使用一对花括号括起来的代码区域）
    + 函数作用域：仅用于goto语句
    + 函数原型作用域：函数形参
    + 文件作用域：全局变量

    翻译单元：一个源代码文件和它所包含的头文件

  + **链接**：

    + 外部链接：属于文件；可在多个文件程序中使用

    + 内部链接：属于文件；只在一个翻译单元中使用

      关键字：`static`标注——只表明链接属性

    + 无链接：属于它们的块、函数或原型私有

  | 作用域 | 块作用域、函数作用域、函数原型作用域 | 文件作用域                                     |
  | ------ | ------------------------------------ | ---------------------------------------------- |
  | 链接   | 无连接                               |                                                |
  | 链接   |                                      | 内部链接的文件作用域（文件作用域）             |
  | 链接   |                                      | 外部链接的文件作用域（全局作用域、程序作用域） |


| 存储类别     | 存储期 | 作用域 | 链接 | 声明方式                       | 说明 |
| ------------ | ------ | ------ | ---- | ------------------------------ | ---- |
| 自动         | 自动   | 块     | 无   | 块内                           |      |
| 寄存器       | 自动   | 块     | 无   | 块内，使用关键字`register`     |      |
| 静态外部链接 | 静态   | 文件   | 外部 | 所有函数外                     |      |
| 静态内部链接 | 静态   | 文件   | 内部 | 所有函数外，使用关键字`static` |      |
| 静态无链接   | 静态   | 块     | 无   | 块内，使用关键字`static`       |      |

1. 自动变量

   + 为了表明有意覆盖一个外部变量定义，或者强调不要把该变量改为其他存储类型，可以显示的使用*存储类别说明符*关键字`auto`。

   + 不同块可以使用同名变量，它们具有不同的内存

   + 嵌套结构出现同名变量，内层块会*隐藏*外层块

   + C99特性，循环分支内容是本体的子块，子块变量在一次循环分支完消失。

     ​				`for (int n = 1; n < 3; n ++) { int n = 4; n ++; }`

     ​				外层以n作为索引，在里层声明新的n，在一次循环后，里层n消失，再次以外层n作为索引

   + 自动变量的初始化：不会自动初始化，除非显式的用非常量表达式初始化它，不然分配给空间中的任意值。

2. 寄存器变量

   + register类别与直接命令相比更像是一种请求，可能将变量存储在CPU的寄存器中，从而更快的访问内存
   + 但是无法获得寄存器变量的地址，即使没能”幸运的“进入寄存器。
   + 数据类型有限，没有足够大的空间。

3. 块作用域的静态变量（内部静态存储类别——函数内部，而非内部链接）

   + 在函数内部使用`static`声明，内存一直存在，块内使用时要用`static`声明

4. 外部链接的静态变量（外部存储类别、外部变量）

   + 在所有函数外创建外部变量，
   + 为了指出函数内使用外部变量，可以在函数中使用关键字`extern`再次声明
   + 如果源代码文件使用的外部变量在另一个源代码文件中，则必须使用`extern`在该文件中声明该变量
   + 初始化外部变量：会自动初始化为0，初始化只能用==常量表达式==初始化文件作用域变量

5. 内部链接的静态变量（外部静态变量）

   + 在所有函数外部，用存储类别说明符`static`定义的变量。
   + 可以在文件内部使用存储类别说明符`extern`重复声明任何文件作用域的变量

+ 存储类别说明符

  | 关键字          | 说明                                                         |
  | --------------- | ------------------------------------------------------------ |
  | `auto`          | 说明变量是自动存储期，只能用于块作用域<br />明确使用与外部变量同名的局部变量的意图 |
  | `register`      | 用于块作用域的变量，把变量归为寄存器存储类型<br />请求最快速度访问该变量，同时，还保护该变量的地址不被获取 |
  | `static`        | 创建对象具有静态存储期，文件作用域，作用域限于该文件<br />在块内使用，只能块内用，但一开始就分配内存 |
  | `extern`        | 表明该变量定义在别处                                         |
  | `_Thread_local` |                                                              |
  | `typedef`       | 与内存存储无关，归于此类与语法有关                           |

+ 函数存储类别

  + 外部函数（默认）
  + 静态函数：`static`：只翻译单元内有用
  + 内联函数：`inline`：

+ 通过函数管理内存

  静态存储类型的内存在编译时确定。

  自动存储类型的内存存在于所在块中，并随同一起消失，随着函数的调用和结束，内存数量相应的增加或减少，做部分内存作为栈处理。

  动态分配内存与内存管理函数有关，由程序员管理，而不是一套规则，内存在整个内存中分散，故速度较于栈内存更慢。（通常称为*内存堆*或*自由内存*）

+ ANSI C*类型限定符*

  变量属性：类型、存储类别和限定符属性

  | 标准 | 新增                                                         |
  | ---- | ------------------------------------------------------------ |
  | C90  | 恒常性，关键字`const`<br />易变性，关键字`volatile`          |
  | C99  | 幂等性（一条声明可以多次使用同一限定符，多余限定符将被忽略）<br>限定符`restricct` |
  | C11  | 限定符`_Atomic`                                              |

  + `const`类型限定符：声明变量为只读变量  ==//zweix_const==

    + 函数中，`const`关键字可以告诉编译器，函数将数组视为常量、不可更改。

    + `const`和指针：个人理解：`const`限制与在`*`号的相对位置的有关，数组表示法和指针表示法是管理数组的两个途径。

      + `const int * pd = arr;` `pd`可以修改，但不能通过`pd`修改数组，而数组可以修改

      + `int * const pd = arr;` 此时pd不能指向其他地址。但可以修改地址的值

      + 限制对象：`*`号左侧属于前者，`*`号右侧属于后者

        即`const int * pd = arr` 与 `int const * pd = arr` 等价

        当然，也可以都限制`const int * const pd = arr;` 。

      + `const`限制的数组的地址不能被赋予——防止通过指针途径修改数组

      + 另外，在函数传递时，`const`的数组传给无`const`的指针有风险，结果未被定义。

    + `2021.9.30`更：对于const限定的到底是指针本身还是其指向，const限定的是后面的变量，如果const在`*`前无论是数据类型前还是后，其限定的是`*变量名`，而变量是一个指针，所以这个是其所指向的值，所以const限定的是`*变量名`，也就是这个指向的值，但如果const在`*`后面，则其限定的是`变量名`，这是一个指针，所以const限定的是这个指针，即指针的指向不能变。

  + `volatile`类型限定符：告知计算机，代理可以改变该变量的值。

    意义：涉及编译器的优化

    > 高速缓存：对于连续使用并且未修改其值，则编译器将其放在寄存器上，这样读取时可以节约时间
    >
    > ​                    但是如果过程中代理改变了值，就不能这样优化了。

    `const`和 `volatile` 同时限定一个变量：只能通过代理修改。

+ `restrict`类型限定符：只能用于指针，表明指针是访问数据对象的唯一且初始的方式。

  ​										 允许编译器优化某部分代码以更好的支持计算

  数组的指针表示法和数组表示法指出同一份数据有不同表示方法进行修改，相邻语句的同类型的修改方法进行可化简的修改，不能保证之间存在不同类型的修改方式进行不可化简得修改。而限定符可以保证其他方式不能修改。

  ege：

  ``` cpp
    int a[10];
  int * pa = a;
    for (int i = 1; i <= n; i ++) {
  	a[i] += 3;
      pa[i] *= 2;
      a[i] += 5;  //所以编译器不能直接化简为a[i] += 8;
    }
  ```

  + 还可用于函数形参中得指针，意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据。

+ `_Atomic`类型限定符：并发程序中表示其他线程不能修改其值。

## 运算符

1. C++的符号：运算符以及其他保留字（如const）

2. 运算符的操作对象：运算对象

   + 特性：操作数数目、返回值、优先级和结合律（不同编译器运算顺序可能不同）

   > + 副作用：对数据对象或文件的修改。
   >
   >   比如一个表达式语句，结果修改了左值的值，但是目的只是做这个表达式本身，所以修改时“副作用”。
   >
   >   再比如，调用`printf()` 函数，调用才是目的，打印只是“副作用”。
   >
   > + 序列点：程序执行的点，所有副作用都在进入下一步之前发生。
   >
   >   ​				无任何一个完整表达式的结束也是一个序列点。
   >
   >   + 完整表达式：不是一个更大表达式的子表达式。
   >
   >     ​						比如一个分号前不对一个变量进行两次自增或自减，C不能保证在执行中其按时变化。
   >
   > 一个运算符的返回值是对操作数进行相应的操作后的结果，而这个结果也是一个可操作的右值。

+ 数学运算符

  + 赋值运算符：`=`

    目的：把值存储到内存位置上。

    + *数值对象*：用于存储值得 数据存储区域得统称。——实际的存储区域  

    + *左值*：标识特定数据对象得名称或表达式。         ——标识定位存储区域的标签

      ​			由于const，新增术语：*可修改的左值*；当前标准建议：使用术语*对象定位值*。  ////C++称为实体名称

    + *右值*：能赋值给可修改左值的量，且本身不是左值。可以是常量、变量或其他可求值得表达式——表达式的值。

    返回值为顺序点结束时左值的值——可连续赋值（从右往左）

    其他算术运算符结合：`+=`、 `-=`、 `*=`、 `/=`、 `%=`；代码更紧凑、形成的机器代码更高效

  + 加法运算符：`+`

    + 二元运算符，返回两个操作数的和，类型遵循类型转换
    + 一元运算符，符号运算符，表明正负，返回操作数

  + 减法运算符：`-`

    + 二元运算符，两个相减
    + 一元运算符，符号运算符，表明正负，返回操作数的相反数

  + 乘法运算符：`*`

  + 除法运算符：`/`

    + 浮点数除法的结果是浮点型
    + 整数触发的结果是整型，小数部分被*截断*（*趋零截断* >< 四舍五入）

  + 求模运算符：`%`

    用于整数运算（浮点型不可以），得到余数。

    `a % b == a - (a / b) * b`

    **分子不可以是0！**，在编程的时候要考虑这个情况。

  + 递增运算符：`++`（一元）

    + 前缀模式：++出现在其作用的变量前面，先加后用。
    + 后缀模式：                                                   先用再加。

    递增运算符生成的机器语言代码效率更高，随着编译器越来越智能，这个优势可能会消失。

  + 递减运算符：`-- `（同上）

+ 关系运算符：返回逻辑计算后的真值

  + 相等运算符：`==`  //初学者不要与赋值运算符搞混 实际上在关系表达式中建议常量放在左侧，便是为此。

  + 其他

    | 运算符 | 含义       |
    | ------ | ---------- |
    | `<`    | 小于       |
    | `<=`   | 小于或等于 |
    | `==`   | 等于       |
    | `>=`   | 大于或等于 |
    | `>`    | 大于       |
    | `!=`   | 不等于     |

  + 浮点数尽可能不用==、<=和>=，只用<和>，因为浮点数的舍入误差会导致逻辑上应该相等的两数不相等。

+ 逻辑运算符

  | 逻辑运算符 | 含义 | note |
  | ---------- | ---- | ---- |
  | `&&`       | 与   | 短路 |
  | `||`       | 或   |      |
  | `！`       | 非   |      |

  + 备选拼写：iso646.h头文件（C99）

    用and代替&&，用or代替||，用not代替！。

  + 逻辑运算符本身是序列点

+ 条件运算符（三元运算符）：` ? : ` 格式： `expressio1 ? expression2 : expression3; ` 编译器可以生成更紧凑的程序代码

+ 特殊运算符

  + `sizeof `或 `sizeof()`和`size_t类型`

    以字节为单位返回运算对象的大小，运算对象是具体的数据对象可以无括号、是类型则必须有括号。（建议都括号）

    `sizeof`返回`size_t`类型（无符号整数类型，语言定义的标准类型）的值

  + 强制类型转换运算符：即在某个量的前面防止用圆括号括起来的类型名：`(type)`——避免自动转换可能出现的降级。

  + 逗号运算符：`, `

    把两个表达式连接成一个表达式，整个表达式是右侧表达式的值。

    是一个序列点，保证被他分隔的表达式从左往右求值，副作用在其之前发生。

  + 地址运算符：`&`

    一元

    后接变量获得地址

  + 间接运算符（解引用运算符）：`*`

    一元

    后接地址获得值

  + `->`

  + `.`

  + `[]`

+ 优先级和求值顺序  //==zweix_优先级==

  优先级从高到低。结合律适用于共享同一运算对象的运算符，并列级别与硬件有关

  | 运算符                       | 结合律       |
  | ---------------------------- | ------------ |
  | () []                        | 从左往右     |
  | .                            | 从左往右     |
  | ++ --   ！ *（解引用运算符） | **从右往左** |
  | + - （一元）                 | 从右往左     |
  | sizeof                       | 从右往左     |
  | * / %                        | 从左往右     |
  | + - （二元）                 | 从左往右     |
  | < > <= >=                    | 从左往右     |
  | == !=                        | 从左往右     |
  | && \|\|                      | &&高于\|\|   |
  | 位操作                       |              |
  | =及其他赋值运算符            | 从右往左     |

+ 位操作运算符

  术语：位、二进制数、字节、八位组、高阶位、低阶位；八进制、十六进制

  1. 有符号整型

     1. 符号量：高阶位存储符号。

        ​				缺点：有正零和负零。

     2. 二进制补码：反转加一

     3. 二进制反码

  2. 二进制浮点数：二进制小数+二进制指数。

  3. 对齐特性（C11）

  ----

  1. 按位运算符（可与等号结合）

     1. 按位取反：`~`
     2. 按位与：`&`
     3. 按位或：`|`
     4. 按位异或：`^`
  
     + 用法：

       `int MASK = num;` 将控制的位设置为1，其余为0.

       1. 掩码：按位与：掩码1可见，0不可见。`sam &= MASK;`
       2. 打开位（设置位）：按位或：1打开，0不打开。`sam |= MASK;`
       3. 关闭位（清空位）：取反后，01反转，不可见变可见。`sam &= ~MASK`;
       4. 切换位：异或
       5. 检查位的值：`(sam & MASK) == MASK;`
  
  2. 位移运算符（可与等号结合）

     1. 左移：`<<`
     2. 右移：`>>`
  
     + 用法：
       1. 移位运算符
  
  3. 位字段：是一个signed int 或 unsigned int 类型变量中的一组相邻的位（C99和C11新增了_Bool类型的位字段）。

     ​				通过结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度。

     ```cpp
     struct {
     	unsigned code1 : 1;
         unsigned code2 : 1;
         unsigned code3 : 2;
         ……
     } sam;
     sam.code1 = 1;
     sam.code2 = 0;
     sam.code3 = 3;
     ```
  
     ​				可以设定成员变量的存储宽度。合理分配存储空间。但是要确保所赋值不超多字段可容纳范围。

     比如code3的字段长是2，则其能存储的值只能是0~3
     
     + 总位数不能超多unsigned int类型的大小；
     
       否则，会到下一个unsigned int类型的存储位置，一个字段不允许跨越两个unint之间的边界；编译器会自动移动跨界的字段，保持unint的边界对其，一旦发生这种情况，第一个unint中会会留下一个未命名的”洞“；可以使用未命名的字段宽度”填充“未命名的”洞“，再使用一个宽度为0的未命名字段迫使下一个字段与下一个整数对齐
     
       ```cpp
       struct {
       	unsigned int field1 : 1;
           unsigned int		: 2;
           unsigned int field2 : 1;
           unsigned int		: 0;
           unsigned int field3 : 1;
       } stuff;
       ```
     
     + 字段存储在一个int的顺序取决的预计的实现。——位字段不易移植。
     
     + 用法：
       1. 一个事物的不同属性：按位编码：门的透不透明是二选的，具体颜色是多元的，就可以分成多个字段

# 语法

+ **关键字**：语言定义的单词，不能用作其他用途。
+ **标识符**：一个变量、常量、函数和其他实体的名称。  //==zweix_命名规则==
  + 命名规则：
    + 由小写字母、大写字母、数字和下划线(_)组成，且名称的第一个字符必须是字母或下划线，不能是数字。
    + ***保留标识符***经常以一个或两个下划线开始，最好避免。
    + 区分大小写。
    + C99和C11根据*通用字符名*机制添加了拓展字符集。
    + 常量建议大写或用c\_和k\_前缀表示常量
+ 转义序列：见数据-数据类型-整数类型-字符型。


+ 转换说明：见语法-函数-输入输出-标准输入输出。
+ 运算符：

  + 运算对象

+ 表达式：运算符+运算对象。

  + 子表达式：更小的表达式。

+ **语句**：是由关键字、标识符和运算符组成的表达式（+大部分语句以分号结尾）。

  + C程序的基本模块，一条语句相当于一条完整的计算机指令，但指令未必是语句——子表达式。

+ + 副作用：对数据对象或文件的修改。

    比如一个表达式语句，结果修改了左值的值，但是目的只是做这个表达式本身，所以修改时“副作用”。

    再比如，调用`printf()` 函数，调用才是目的，打印只是“副作用”。

  + 序列点：程序执行的点，所有副作用都在进入下一步之前发生。

    ​				无任何一个完整表达式的结束也是一个序列点。

    + 完整表达式：不是一个更大表达式的子表达式。

      ​						比如一个分号前不对一个变量进行两次自增或自减，C不能保证在执行中其按时变化。

+ **块**：花括号（{}）包裹的若干语句。

## 预处理器

是指在进行编译的第一遍扫描 (词法扫描和语法分析)之前所作的工作。

指令可在C程序任意位置。ASCII允许#之前有空格或制表符。

编译时编译器调用相关程序进行预处理。

1. `#define`预处理宏  //==+zweix_类函数宏以及运算符没有实例==

   + 格式：`#define 宏 替换体（替换列表）`

     + 宏的分类

       1. 类对象宏：定义*明示常量*（*符号常量*）：助记、易更改、可移植。

          > 记号型字符串：被空格分开
          >
          > 字符型字符串：认可空格是字符串的一部分
          >
          > ege：`#define FOUR 2 * 2` 和 `#define SIX 2*3`
          >
          > 前者三个记号：2 * 2，后者一个记号2*3

       2. 类函数宏：使用参数创建外形和作用与函数类似的类函数宏

          ​					必要时要使用足够多的圆括号来确保运算和结合的正确性

          ​					不要将自增自减的变量作为参数，这种行为是没有被定义的。

          + 与函数选择：

            宏生成内联代码，调用就是插入代码，而函数只生成一个函数语句副本——函数节省空间

            函数需要跳转——内联代码更块

            宏不需要担心变量类型
            
            > C99提供关键字`inline`生成内联函数
            
          + ege：
          
            ```cpp
            #define PRINTF(x) printf("xxx%d", x);
            PRINTF(4);  //xxx4
            #define PRINTF(x) printf("xxx%d", ((x)*(x));
            PRINTF(4);  //xxx16
            ```
          
            

     + 宏的名称不允许有空格，遵循C变量的命名规则。

     + *宏展开*：预处理器在源代码找到宏的示实例后，就会用替换体代替该宏。

       ​				如果替换后还包括宏，则继续替换，除非双括号中的宏

   + 运算符：

     1. `#`运算符：用宏参数创建字符

        替换体中的双引号字符串中的文本视为普通文本，如果想在此中使用参数，#号作为一个预处理运算符，可以把记号转换成字符串

        ```cpp
        #define PRINTF(x) printf("#xxx%d", ((x)*(x));
        PRINTF(4);  //4xx16
        ```

     2. ##运算符：预处理器黏合记

        用于类函数宏的替换部分，把两个记号组合成一个记号——把参数作为文本。
        
        ```cpp
        #define XNAME(n) X ## n
        XNAME(4);  //X4
        XNAME(y);  //Xy
        ```
        
     
   + 变参宏：`...` 和 `__VA_ARGS__ `。
   
     C99/C11为宏提供了类似参数数量*可变*的函数的工具。
   
     ege:`#define PR(...) printf(__VA_ARGS__)` 使用时，利用字符串的串联功能和#运算符。
     
   + C库预定义宏
   
     | 宏     | 含义         |
     | ------ | ------------ |
     | __DATE | 预处理的日期 |
     |        |              |
     | 其他   |              |
     
   
2. `#include ` 文件包含：查找后面的文件名并把文件的内容包含的当前文件中即替换原文件中的#include指令。这相当于把被包含文件的全部内容输入到源文件#include指令所在的位置。

   + 头文件：.h后缀

     内容：明示常量、宏函数、函数声明、结构模板定义、类型定义。

   + 形式：
     1. `#include <>` 文件名在尖括号中，文件在标准系统目录中查找该文件
     2. `#include ""` 文件名在双引号中， 文件在当前目录中（或文件名中指定的其他目录）查找该文件，如果未找到再查找标准系统目录
   
3. `#undef` 指令：取消已定义的#define指令

   不能取消的已定义的

4. 条件编译：可以通过指令告诉编译器根据编译时的条件执行或忽略信息（或代码）块

   + 1. `#ifdef` 和 `#ifndef` 类似于`if` 语句，后接一个宏，

        + `#ifdef` 如果宏被定义则为真
        + `#ifndef` 如果宏没有被定义则为真

     2. `#else` 和 `#endif` 与上边的指令结合，为真运行`#if def` 和 `#else` 之间的，为假运行`#else`和`#endif`之间的。

        #else为可选项，但是**上述编译指令必须以#endif结尾**。

     ege：

     ```cpp
     #define FLAG
     
     int main() {
         
         
     #ifdef FLAG
         printf("");
     #else
         printf("");
     #endif
         
     }
     ```

     ANSI标准支持缩进格式，旧的编译器必须左对齐。

     可嵌套。

     用法：

     1. 避免宏的重复定义：

        ```cpp
        #ifndef FLAG
        	#define FALG
        #endif
        ```
        
     2. 头文件保护机制/防御式声明

        ege: zweix.h

        ```cpp
        #ifndef ZWEIX_H
        #define ZWEIX_H
        这时自定义的头文件就可以调用声明需要的头文件而不需要使用者引用的头文件冲突。
        同时也不用担心用户在利用自己的头文件进行自定义时产生冲突。
        #endif
        ```

   + `#if`和`#elif`：类似if和else if

     后接整型表达式，可以使用关系和逻辑运算符

     可使用`#if defined (FALG)` 替换 `#ifdef FLAG` 。	

     同样可接`#else` 和需要接 `endif`。

5. `#line`和`#error`

6. `#pragma once`

   可代替ifndef的头文件保护功能，及保证文件只被include一次，但是有些编译器不能识别。

## 语句

是由关键字、标识符和运算符组成的表达式。

+ 注释： `/* 注释 */ `（多行）或者 `// 注释` 单行。
+ 块：用花括号（{}）标记开始和结束的若干语句。

### 表达式语句

1. 声明：把特定标识符与计算机内存中的特定位置联系起来，同时也确定了存储在某位置的信息类型或数据类型。

   + 多条声明，标识符用逗号（`,`）分隔。

   + 经典C要求把变量声明在块的顶部（易查找）。C99、C++允许在使用变量的时候再声明（不会忘记初始化）。
   + 意义：所有变量必须先声明才能使用
     + 变量放在一处，方便查找
     + 必须列出程序所使用的所有变量名及其类型
     + 避免垃圾值（如果没有这条特性，变量不经定义就可以使用，那如果拼写错误了呢？）

   **声明不是语句**——去掉分号后不是表达式。

   + 定义与声明的区别
     + 定义式声明（定义）：分配内存
     + 引用式声明               ：涉及存储类别

   ==格式：类型限定符关键字 数据类型关键字 变量标识符 运算符==

+ 各种表达式语句：赋值表达式语句、函数表达式语句、关系表达式语句

---

### 流程控制语句

其中的expression表达式的判定C++是将表达式的值强制转换为bool类型，C不知道

> 网上认为C也是认bool型，但是C在C99才添加_Bool，这种说法肯定行不通
>
> 2021.9.30更：C有布尔类型，只是在C99之前或者不借助枚举不能直接使用。

其中的statement语句既可以用逗号运算符扩展，也可以使用花括号将若干语句变为复合语句（逻辑上多条变一条）

***循环语句***：

+ 术语
  + *迭代*：每次循环
  + 真假：所有非零值都视为真，只有0被视为假。
  + 嵌套循环：外层循环，内层循环

1. 入口条件循环（不定循环）whlie

  ```c
  while ( expression )
   	statement
  //statement部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句。
  ```

2. （入口条件循环）计数循环for

   + 创建重复执行固定次数的行为

     + 必须初始化计数器
     + 计数器与有限的值作比较
     + 每次循环时递增计数器

   + 格式

     ```cpp
     for ( initialize; test; update )
         statement
     //initialize、test、update都是表达式，可用逗号运算符扩展
     //statement见while介绍
     ```

   + 灵活性：计数、倒计、非一步数、字符替代、其他条件、非线性计数、表达式计数、省略表达式、异性表达式、可变表达式。

3. 出口条件循环：do while

   + 格式

     ```cpp
     do
         statement
     while ( expression)
     ```

+ 循环辅助
  + `continue`
	  + continue其实也是一种跳转，它会跳转到循环块的末尾（而不是直接进行新的循环）
  + `break`

---

*选择（分支）语句*：

+ 术语

1. if语句

   ```cpp
   if (expression )
       statement
   ```

2. if else语句

   ```cpp
   if (expression)
       statement1
   else 
       statement2
   ```

3. 多重选择else if

4. 多重选择switch：只能判断整型表达式（包括字符型），浮点型不可以。

   格式：

   ```cpp
   switch ( expression ) {
       case lace11 : statement1//使用break跳出switch
       case labe12 : statement2
       default 	: statement3
   }
   
   switch ( 整型表达式) {
   	case 常量1：
           语句；
           //break;
       case 常量1：
           语句；
           //break;
       default :
           语句；
   }
   ```

   多重标签：多个标签指向同一语句

   ```cpp
   switch ( 整型表达式) {
   	case 常量1：
       case 常量2：  // 常量1和2都运行语句
           语句；
           //break;
       case 常量3：
       case 常量4：
           语句；
           //break;
       default :
           语句；
   }
   ```
   
   + 对于内部实现：switch会先遍历一遍case表（dafault被认为是除了所有case之外的case），然后决定进入那个分支，即“命中”，命中之后，switch不再具有选择能力，在没有break的情况下，将无选择的顺序执行之后语句。（这里有个反直觉的部分，遍历case表的顺序是先顺序case最后default，命中后的执行顺序就是代码排布的顺序）
   + 

+ 分支辅助

  + gote语句

    格式：goto和标签名。标签的命名遵循变量命名规则。

    ```cpp
    goto part2;
    
    part: statement;
    ```

    一般没有必要用，除非，出现问题时从一组嵌套循环中跳出。

----

*跳转语句*：continue，break，goto。

----

*标签语句*：

-----

*复合语句*（块）

+ 定义：是用花括号（{}）括起来的一条或多条语句

-----

## 函数

定义：完成特定任务的独立程序代码单元。

+ *函数原型*（C90新增）\函数声明（ANSI C）（没有参数名）：告知编译器程序中要使用该函数；即*签名*

  + 形式参数：声明参数时创建，函数内部用。被调函数的参数。
    + 变量名是函数私有的，不同函数内同名函数不冲突。

    ANSI C的函数声明不用写出参数的类型和数目  

    C90的函数原型则更加严格，要求类型数目命名都清楚、没有参数用void；

  + 实际参数：调用函数时使用，外部传递进函数的值。主调函数的参数

  C语言要求原型和定义分开，且原型要在使用前（main函数里外都可以）声明。
+ *函数调用*：使用该函数
+ *函数定义*；函数的源代码
  
  + *函数头*（接口部分）：函数返回类型、函数名和传入该函数的信息类型
  + *函数体*（实现部分）；
  

### 基础知识

1. 内联函数：

   规定于C99，用于加快函数调用速度。

   > zweix觉得C99中的新标准都是对C++的一些适配，内联函数其实是C++，C99让C具有这种特性

   > 原理：编译器将内联函数代码直接嵌入调用它的代码中，并将传递参和返回值部分自动调整
   >
   > ​			因此省去了调用和返回的时间。

   + 术语：

     函数调用的开销：建立调用、传递参数、跳转到函数代码并返回。

   + 关键字：

     + 函数说明符：`inline`：说明函数是内联函数
     + 存储类别说明符：`static`：说明函数是静态函数（见数据-存储类别）

   + 限制：不可用于递归函数

2. 函数指针：

   函数原型中可以省略变量名，但是函数定义中不可以省略——实际上原型和定义中的形参名称可不同，但其安全性要用户保证。

### 主函数

*主调函数*：是C程序的入口，操作系统调用程序的函数，程序从`main()`函数开始。

+ 主函数的返回类型：主函数必须要返回`int`类型，无返回值（`void`）并非所有编译器都支持

  主函数末尾设置`return 0;`如果程序正常结束返回0，如果返回1则说明程序运行出现错误，如果没有设置，C99规定编译器在可执行文件末尾自动生成。

  > 头文件`stdlib.h`定义两个常量宏
  >
  > ```cpp
  > #define EXIT_SUCCESS 0
  > #define EXIT_FAILURE 1
  > ```
  >
  > 来作为return的值

+ 主函数的参数：

  + 无参数：

    1. 空着
    2. 添加`void`

  + 含参数：

    程序主函数写法`int main(int argc, char *argv[])`或`int main(int argc, char **argv)`。

    两个参数：

    1. 第一个参数是命令行中的字符串数量，即参数计数argc

    系统用空格表示一个字符串的结束和下一个字符串的开始。

    2. 之后的参数为参数值argv——命令行字符串存储在内存中，并把每个字符串的地址存储在指针数组。

    部分系统允许把程序本身的名称赋给argv[0]。

### 递归函数

+ 定义：C允许函数调用它自己，这个调用过程叫递归。
+ 基本原理
  + 每级函数调用都有自己的变量。
  + 每次函数调用都会返回一次。
  + 递归函数种位于递归调用之前的语句，均按被调用函数的顺序执行。
  + 递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。
  + 虽然每级递归都有自己的变量，但是并没有拷贝函数代码。
  + 递归函数必须包含能让递归调用停止的语句。
+ 分类：
  + 尾递归：把递归调用置于函数的末尾的最简单的递归形式。
  + 倒序计算：递归调用在结果返回之前。

### 输入输出I/O

1. 缓冲区

   1. 输入分类：
      + 无缓冲（或直接）输入：回显用户输入的字符后立刻重复打印该字符、正在等待的程序可以立刻使用输入字符。
      + 缓冲输入：大部分系统在用户按下ENTER键之前不会重复打印刚输入的字符。

   + 缓冲区：用户输入的字符被收集并储存的临时存储区。

   + 意义：提高传输效率、可修改。

   + *刷新缓冲区*：内容发送至目的地。

     ​						缓冲区大小取决于系统，常见512字节和4096字节。

   2. 缓冲分类：
      + 完全缓冲I/O：当缓冲区被填满时才刷新缓冲区。
      + 行缓冲I/O：在出现换行符时刷新缓冲区。——键盘输入

2. 文件：存储器中存储信息的区域

   + C语言用于打开、读取、写入和关闭文件的库函数：

     + 底层I/O，使用主机操作系用的基本文件工具直接处理文件。

       计算机系统不同，无法创建标准库，不同OS处理文件存在差异

       1. 存储文件的方式：文件相关信息和内容异处、文件内容包含相关信息。
       2. 标记末尾方式：单个换行符、回车符和换行符的组合。
       3. 衡量文件大小：字节、字节块。

     + 标准I/O：同一标准，处理***流***。

3. 流：实际输入和输出映射的理想化数据流。

   ​		不同种类和属性的信息由属性更统一的流表示。

4. 文件末尾；

   + 嵌入特殊标记
   + 存储文件大小的信息
   + C语言以EOF（宏定义为值-1）作为文件末尾信号。

5. 重定向：通过重定向调整信息来源，程序只需要处理抽象的流。与OS有关。

   ​				UNIX、Linux和Window（DOS）重定向

   ​				运算符两边的空格要求与OS有关，建议左有右无。

   > ./ echo_eof < words

   <符号是重定向输入运算符

   $符号是标准提示符（UNIX和Linux），Windows/DOS是`A>`或`C>`

   > ./echo_eof > mywords

   \>符号是重定向输出运算符

   ---

   组合重定向

   制作mywords的副本并命名为savewords

   > ./ echo_eof < mywords > savewords

   命令与重定向运算符的顺序无关

   > ./ echo_eof > savewords < mywords 

   ---

   其他重定向运算符

   + \>> : 把数据添加到文件末尾
   + | ： 把一个文件的输出连接到另一个文件的输出

   ---

   规则：

   + 重定向运算符连接一个可执行程序和一个数据文件。

     不能乱，数目不能多。

6. 输入验证

   编写程序时，要认真设计用户界面。事先预料一些用户可能会犯的错误，然后设计程序妥善处理这些错误情况。

#### 标准I/O

* 格式：

  + `scanf(格式字符串，参数列表)` :

    参数列表里是指针。

    + 读取整数：遇到第一个非空字符开始，遇到空字符结束，并把空字符放回输入。
    + 读取其他数字匹配：不匹配停止。
    + 读取字符串：从第一个非空字符开始，直到遇到空白，并在读取好的字符串尾放入'\\0';

    对于格式字符串中的普通字符

    + 除空格外的必须严格匹配

    + 空格则意味着跳过所有空格

      对`%c`同样适用，即其读取第一个非空字符。

  + `printf(格式字符串,  待打印项1, 待打印项2, ……);`

    格式字符串 = 实际要打印的字符 + 转换说明

    转换说明与待打印项对应匹配，待打印项可以是变量、常量和计算表达式。

+ 转换说明：用于格式化输入输出，决定数据的显示方式（根据存储方式）

  ​					都以占位符（%）开始

  | 操作                 | 转换说明                                    |
  | -------------------- | ------------------------------------------- |
  | 十进制               | %d                                          |
  | 八进制               | %o                                          |
  | 十六进制             | %x                                          |
  | 显示进制前缀         | %#（%#o, %#x, %#X）                         |
  | *下在前上在后可复合* |                                             |
  | int                  | %d（其他附属关键字作其前缀）                |
  | short                | 前缀h                                       |
  | long                 | 前缀l                                       |
  | long long            | 前缀ll                                      |
  | unsigned             | 前缀u（最末尾）                             |
  |                      |                                             |
  | char                 | %c                                          |
  |                      |                                             |
  | 指数表示法浮点数     | %e或%E（此时`.数字`限制e前的数）            |
  | 十六进制浮点数       | 前缀%a或%A                                  |
  | *下在前上在后可复合* |                                             |
  | float                | %f（默认小数点6位）                         |
  | double               | %f                                          |
  | long double          | %L                                          |
  |                      |                                             |
  | 字符串               | %s                                          |
  |                      |                                             |
  | sizeof               | %z 和整型转换说明一起使用 %zd               |
  | 指针                 | %p或者%u和%lu<br>%td或者%d和%ld表示地址差值 |
  
  转换说明修饰符

  | 修饰符    | 含义                                                         |
  | --------- | ------------------------------------------------------------ |
  | 标记      | -：左对齐<br>+：右对齐<br>空格：空余符号位，正号空格，负号显示<br>#：结果转换：不同进制显示对应格式、浮点是保证打印小数点<br>0：对于数值格式，用前导0代替空格填充字段 |
  | 数字(.前) | 最小字段宽度，不能容纳使用更宽                               |
  | .数字     | 精度<br>对于%e、%E和%f转换，小数位数<br>对于%g和%G转换，有效位数<br>对于%s转换，打印字符的最大数量<br>对于整型转换，待打印数字的最小位数，前导0填充 |
  | *         | `printf("%*d", width, num);` <br>后接两个变量，第一个控制宽度，第二个为输出的值 |
  | 输入      |                                                              |
  | *         | 抑制（滞后）赋值<br />跳过对应转换说明（就当它根本不存在）<br />`scanf("%*d%d", &a);`将第二个读取的整数赋给a |
  | 数字      | 最大字符宽度，输入达到最大字段宽度处，或第一次遇到空白字符时停止 |

+ 缓冲区
  + `scanf()` 输入：
  + `printf()` 输出：把输出发送到*缓冲区*（中间存储区域），然后（当缓冲区满、遇到换行字符或者需要输入时）从缓冲区不断发送到屏幕或文件（刷新缓冲区）。另一种刷新缓冲区的方法是使用`fflush()`函数。

+ 参数传递：

  + scanf（）
  + printf（）
    + 调用函数把对应的值传递给程序
    + 程序把传入的值按照变量类型放入*栈*内存
    + 程序控制printf根据转换说明从栈中读取值

+ 返回值

  + `scanf()` 输入：成功读取的项数。否则返回0

    ​							检测到“文件末尾”时，返回EOF（stdio.h的宏定义，其值为$-1$）

  + `printf()` 输出：返回打印字符的个数。

+ note：

  + `scanf()` 输入：遇到不符合要求的，会返回输入，下次输入还从这里开始。
  + `printf()` 输出：
    + 格式字符串较长
      + 多个
      + 反斜杠（\）和Enter键，这时第二行必须从最左边开始，不然缩进的空格会被认为是字符串的一部分
      + 多个字符串

#### 字符I/O

`ctype.h`头文件的系列字符函数

单字符I/O

| 说明     | 输入                                      | 输出         |
| -------- | ----------------------------------------- | ------------ |
| 函数     | `scanf("%c", )`<br>                       | `printf()`   |
| 预处理宏 | `getchar()`<br>从输入队列中返回下一个字符 | `putchar() ` |

字符测试函数：`is#()`判断是不什么什么的函数，比如是不是字母啊、是不是数字啊、是不是标点啊。

字符影响函数：`to#()`把字符从大写变小写或者变回来。

#### 文件I/O

+ 文件：在磁盘或固态硬盘上的一段已命名的存储区

+ 文件模式：

  + 文本模式：程序可以访问文件的每个字节
  + 二进制模式：文件内容映射为C模式

+ I/O的级别

  + 底层I/O：使用操作系统提供的基本I/O服务

  + 标准高级I/O：使用C库的标准包和头文件定义

    好处：

    1. 简化不同的I/O问题
    2. I/O都是**缓冲**的——速度快，逐字符访问的错觉。

+ （C的）标准文件I/O

  + 标准输入
  + 标准输出
  + 标准错误输出

`#include <stdio.h>` 标准I/O函数

+ 机理

  1. 调用`freopen()`打开文件，创建缓冲区和一个包含文件和缓冲区数据的结构，并返回一个指向该结构的指针即打开一个流

     > 结构包含：指定流中当前位置的文件位置指示器，错误和文件结尾指示器、指向缓冲区开始处的指针、文件标识符和计数（统计实际拷贝进缓冲区的字节数）

  2. 调用在`stdio.h`和输入函数，一旦调用，文件中的缓冲大小数据块就被拷贝到缓冲区

     > 缓冲区大小因实现而异，通常是512字节或者它的倍数，4096或16384

  3. 读取，并记录（结构中的东西），读完再次拷贝。

  4. 输出类似，到缓冲，填满拷贝至文件。


1. + `fopen()`函数

     参数：第一个参数为待打开文件的名称（包换该文件名的字符串地址），第二个参数为指定待打开文件的模式。

     + 文本模式

       | 模式字符串                                                   | 含义                                                         |
       | ------------------------------------------------------------ | ------------------------------------------------------------ |
       | "r"                                                          | 以读模式打开文件                                             |
       | "w"                                                          | 以写模式打开文件，把现有文件长度截为0，如果文件不存在，则创造一个新文件 |
       | "a"                                                          | 以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创造一个新文件 |
       | "r+"                                                         | 以更新模式打开文件（即可以读写文件）                         |
       | "w+"                                                         |                                                              |
       | "a+"                                                         |                                                              |
       | "rb"、"wb"、"ab"<br>"rb+"、"r+b"<br>"wb+"、"w+b"<br>"ab+"、"a+b" | 与上一个模式类似，但是以二进制模式而不是文本模式打开文件     |
       | "wx"、"wbx"<br>"w+x"<br>"wb+x"、"w+bx"                       | C11新增<br>类似非x模式，但是如果文件已存在或以独占模式打开文件，则打开文件失败 |

     返回：文件指针（其类型是指向FILE的指针）

     ​			FILE是一个定义stdio.h中的派生类型，并不指向实际的文件，它指向一个包含文件信息的数据对象。

     ```cpp
     #include <stdio.h>
     #include <stdlib.h>
     int main(int argc, char *argv[]) {
     	int ch;
         FILE *fp;
         if (argc != 2) {
     		printf("Usage: %s filename\n", argv[0]);
             exit(EXIT_FAILURE);
         }
         if ((fp = fopen(argv[1], 'r')) == NULL) {
             printf("Can't open %s\n", argv[1]);
             exit(EXIT_FAILURE);
         }
         while ((ch == getc(fp)) != EOF) {
             
         }
         
         fclose(fp);
         
         return 0;
     }
     ```

   + `fclose()`函数

     与fopen配套使用，关闭文件，参数为文件指针；

     必要时刷新缓冲区；

     关闭成功返回0，否则放回EOF；如果磁盘已满、移动硬盘被移除或者出现I/O错误，都会导致调用fclose（）函数失败

2. 这两个函数与getchar（）和putchar（）类似，实际后者由前者定义

   前者多了文件指针参数，可以是具体指针，或者标准文件指针

   | 标准文件 | 文件指针 | 通常使用的设备 |
   | -------- | -------- | -------------- |
   | 标准输入 | stdin    | 键盘           |
   | 标准输出 | stdout   | 显示器         |
   | 标准错误 | stderr   | 显示器         |

   而使用标准文件指针的文件I/O与标准I/O一致

   + `getc()`函数

     参数：文件指针

     返回：读取的字符

   + `putc()`函数

     参数：输出字符，文件指针

3. 这两个函数与scanf（）和printf（）类似，区别在于前者需要用第一个参数指定待处理的文件

   + `fprintf()`
   + `fscanf()`

4. 

   + `fgets()`

     参数：第一个参数表示存储输入位置的地址，第二个参数是待输入字符串的大小，第三个参数是文件指针

     ​			字符串大小与字符串长度不同，前者指该字符串占用多少空间，后者指该字符串的字符个数

   + `fputs()`

     参数：第一个参数是字符串地址，第二个参数是文件指针

5. 随机访问：打开文件中直接移动到任意字节处。

   + `fseek()`

     参数：三个参数

     1. 第一个参数是FILE指针，指向待查找的文件，fopen（）应该已打开该文件

     2. 第二个参数是*偏移量*，表示从起始点开始要移动的距离，该参数必须是long类型

        ​										正前移、负后移、0保持不动

     3. 第三个参数是模式，确定起始点——stdio.h头文件规定了几个表示模式的明示常量

        | 模式     | 偏移量的起始点 |      |
        | -------- | -------------- | ---- |
        | SEEK_SET | 文件开始处     |      |
        | SEEK_CUR | 当前位置       |      |
        | SEEK_END | 文件末尾       |      |
     
     返回：int类型的值
     
      + 正常：0
      + 错误（超出文件范围）：-1

   + `ftell()`

     返回：long类型的值，指向文件的当前位置距文件开始处的字节数

6. 上面的两个函数将文件大小限制在long类型，为了使用更大的文件，

   这两个函数使用新的类型：`fpos_t`（file position type，文件定位类型），不是基本类型，由其他类型定义，不能是数组类型。

   + `fgetpos()`函数：`int fgetpos(FILE *stream, fpos_t * restruct pos)`
   + `fsetpos()`函数：`int fsetpos(FILE *stream, const fpos_t *pos)`

### 字符串函数

输入输出

1. 首先分配空间

   1. 建立足够大的数组
   2. 使用函数

2. 输入

   `char str[N];`开辟`N`个`char`型的空间，`str`为这个空间的首地址。

| 说明                                 | 输入                                                         | 输出                                                         |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 函数                                 | `scanf("%s", str);`以下一个空白字符作为字符串的结束<br>`scanf("%nums", str);`（指定宽度），则终止条件加上到长度。<br>不指定宽度也会有外溢的风险 | `printf("%s", 字符串地址);`<br>显示字符串                    |
| 预处理宏<br>C99不建议使用<br>C11废除 | `gets(str)`<br>读取整行至换行符，丢弃换行符，添加空字符<br>不会检测char数组大小——***缓冲区溢出*** | `puts(字符串地址)`<br>显示字符串，并在末尾添加换行符<br>从起始地址开始，不一定是数组首，中间同样有效<br>遇到空字符结束，所以必须是字符串，字符数组函数不知何时停止。 |
| C11新增get代替                       | `gets_s(str, len);`<br>读取整行至换行符或len-1，丢弃换行符，添加空字符<br>特性：读取最大时没有换行符，则将目标数组尾字符设为空字符，读取并丢弃随后的输入直至读到换行符或文件结尾，然后返回空字符，接着，须调用“处理函数”，否则中止程序。 |                                                              |
|                                      | `fgets(str, len, 输入文件或stdin)`<br>读取至换行符或len-1，不丢弃换行符，添加空字符<br>成功返回str，读到文件末尾返回***空指针*** | `fputs(str， 输出文件或stdout)`<br>显示字符串，不添加末尾换行符 |

+ 缓冲区溢出：多余的输入超过指定的目标空间。
  + 占用尚未使用的空间
  + 擦写掉程序中的其他数据
+ `stdin`和`stdout`标准输入输出。

+ 空指针

  特殊的指针，保证不指向有效数据

  可用数字0代替，一般用*宏NULL*

+ 综上，`fget`最安全，但会多余换行符，我们处理掉（这里注意fget特性保证存储的字符串最多存在一个换行符），我们然后丢弃同行之后的字符，并作出`s_get(str, len)`字符串输入函数。

  ```c
  char * s_gets(char * st, int n) {
      char * ret_val;
      int i = 0;
      
      ret_val = fget(st, n, stdin);
      if (ret_val) {
  		while (st[i] != '\n' && st[i] != '\0') i ++;
          if (st[i] == '\n') st[i] = '\0';  //遇到换行，换掉
          else while (getchar() != '\n') continue;  //遇到末尾，丢弃同行剩余
      }
      return ret_val;
  }
  ```

其他函数：

`string.h`头文件

| 函数原型                                                     | 作用                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| int strlen(const char * str)                                 | 返回长度                                                     |
| char * strcat(char * str1, const char * str2)                | 把第二个参数的备份接到第一个参数，并返回第一个参数地址       |
| char * strncat(char * str1, const char * str2, int len)      | strcat不能检测第一个参数长度是否足够，第三个参数指定最大添加字符数 |
| int strcmp(const char * str1, const char * str2)             | 返回按机器排序序列的差值（第一个参数减去第二个参数）         |
| int strncmp(……, ……, int seat)                                | 只比较第seat个参数的位置                                     |
| char * strcpy(char * str1, const char * str2)<br />strcpy(目标字符串，源字符串) | 将第二个参数指向的字符串拷贝至第一个参数指向的数组中<br />第一个参数：指针指向一个具有足够空间存储源字符串的数据对象<br />且其不必指向数组的开始<br />第二个参数：指针、数组名或字符串常量<br />返回**第一个参数**的首地址 |
| char *strncpy(char * str1, const char * str2, int len)       | strcpy不能检测空间是否足够<br />第三个参数指定最大长度，至结尾或最大长度时停止<br />如果到最大长度时停止，则目标字符串不含空字符，所以要人工添加 |

`stdio.h`头文件

| 函数原型                                            | 作用                     |
| --------------------------------------------------- | ------------------------ |
| sprintf(目标字符串地址，格式字符串，待写入项的列表) | 把多个元素组合一个字符串 |

### 内存管理函数

+ 头文件`#include <stdlib.h>`

+ `malloc()`

  1. 用法：malloc的参数为开辟的内存大小，通常格式为`number * sizeof(type)`，返回开辟空间的首地址。

     ​			返回类型为void类型的指针（ANSI C标准后），故需要强制转换到对应类型指针（C++必须）

     ​			ege：`double * ptd = (double *) malloc(30 * sizeof(double));`

     ​			`malloc`可能分配不到内存，这时函数放回空指针`NULL`。

     + `malloc`（创建二维数组）

       ``` cpp
       int n = 5, m = 6;
       int ar2[n][m];  //
       int (* p2)[6];  //
       int (* p3)[m];  //
       p2 = (int (*)[6]) malloc(n * 6 * sizeof(int));  //
       p3 = (int (*)[m]) malloc(n * m * sizeof(int));  //
       ar2[1][2] = p2[1][2] = 12;
       ```

  2. 意义：

     1. 数组名是该数组首元素的地址，故这种方法可以作为创建数组的方法，并且是可变长（动态）数组。

+ `free()`

  1. 用法：与`malloc ()`配套使用，`free()`的参数是一个指针，指向由`malloc`分配的一块内存，不能释放其他方式分配的内存。

     ​			`free`的指针可以与`malloc`不同，但必须指向同一块内存，且不可以重复释放

  2. 意义：

     1. 避免*内存泄漏*（忘记使用`free`）
     
  3. 注意：

     + 以上两者一定要配套使用
     + 不可以用free重复释放一块内存多次，这种行为未被C定义。

+ `calloc()`

  1. 用法：`calloc(存储单元数量， 存储单元的大小)`，在开辟的内存中填充0值，其他和`malloc`一样。

     ​			内存可以用`free`释放。
     

### 其他标准C库

+ `exit()`函数关闭所有打开的文件并结束程序（头文件`stdlib.h`）
  
  + `exit(EXIT_SUCCESS);` （相当于0）表示普通的程序结束。
  + `exit(EXIT_FAILURE);` （相当于1）表示程序异常终止。
  
  效果与return相同，但是在递归函数中，exit直接结束程序，return则是返回上一层递归。
